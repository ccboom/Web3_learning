# Cast：命令行 JSON-RPC 客户端

搞定了 Forge 的测试部分，今天我们学习 Cast。

---

## 第一部分：什么是 Cast？

### 定义

Cast 本质上是一个**命令行界面的 JSON-RPC 客户端**。

当你写脚本去和区块链交互的时候，你通常会封装很多逻辑，而 cast 让你直接在终端里，手动构造发给节点的原始请求。这对于调试、快速验证想法，或者解码链上十分混乱的 HEX 数据极其有用。

---

## 第二部分：基础命令演示

### 连接以太坊主网

我们直接开始演示，连接以太坊主网，看看真实数据，而不是自嗨。

打开 WSL 终端，输入以下命令：

```bash
cast block-number --rpc-url https://eth.llamarpc.com
```

这时候应该看到一个数字，再输入以下命令：

```bash
cast chain-id --rpc-url https://eth.llamarpc.com
```

这时候得到的结果应该是 `1`。

### 底层原理：JSON-RPC

虽然看起来很简单，cast 在背后向节点发送了 HTTP POST 请求。

本质上，区块链节点是一个听 HTTP 请求的服务器，cast 只是帮你把命令行转换成了一个标准格式的 HTTP POST 请求，这个通讯标准就叫 **JSON-RPC**。

当你写下 `cast block-number` 时，cast 在背后打包了一个这样的信封：

```json
{
  "jsonrpc": "2.0",           // 告诉节点：我说的是 2.0 版本的通用语言
  "method": "eth_blockNumber", // 核心：我要调用的具体函数名
  "params": [],               // 参数：查最新区块不需要参数，所以是空的
  "id": 1                     // 编号：为了把请求和响应对上号
}
```

当你理解这一点，你就能明白，所有的库（Ether.js、Foundry）底层全部都是在发送这些 JSON 包。如果你哪天需要调试一个极其底层的错误，或者说像刚才说的手写裸交易，你其实就是在手动构造这些 JSON。

---

## 第三部分：手动构造 JSON 请求

### 使用 curl 发送原始请求

现在我们来手动构造一次信件试试。

直接使用 curl（一个通用的网络请求工具）把这个信发给节点。

直接在终端运行下面的代码：

```bash
curl -X POST https://eth.llamarpc.com \
-H "Content-Type: application/json" \
-d '{"jsonrpc":"2.0","method":"eth_blockNumber","params":[],"id":1}'
```

你会收到一段类似 `{"jsonrpc":"2.0","id":1,"result":"0x..."}` 的返回数据。

### 解析返回值

`result` 里面收到一个 16 进制的值，现在肯定是看不明白。我们再使用 cast 的工具。

试着在终端输入：

```bash
cast --to-dec <你的16进制数>
```

看看 10 进制是多少？是不是比刚才获取的 `block-number` 大一些？

这是因为以太坊每 12 秒会产生一个新区块，你运行第一条和第二条命令的间隙，世界各地又有新的区块产生了。

这一步很关键，证明你看到的每一条数据都是真实的、在这个瞬间发生的链上状态。

---

## 第四部分：与智能合约对话

### 查询 DAI 总供应量

现在我们来升级难度，直接和智能合约对话，使用 `cast call`。

假设我们现在要查 DAI 代币（以太坊上最经典的稳定币）在主网的总量（Total supply）。

**DAI 合约地址**：`0x6b175474e89094c44da98b954eedeac495271d0f`

### 函数选择器的计算

在 EVM 的底层逻辑里面，我们不能直接把单词 `totalSupply()` 发给合约，这样合约看不懂。我们需要把函数签名转换为一个 4 字节的函数选择器。

利用手里的 cast 工具，使用 keccak 来转换：

```bash
cast keccak "totalSupply()"
```

而且我们只需要前 4 个字节，也就是 `0x18160ddd`。

**转换对照**：

- 人类读的是：`totalSupply()`
- EVM 读的是：`0x18160ddd`

### 构造完整的 call 命令

现在我们有了所有的拼图碎片，把他们组装起来，像主网的 DAI 合约发送真正的询问。

我们需要用到 `cast call` 命令，它的基本格式是：

```bash
cast call [合约地址] [发送的数据] --rpc-url [节点URL]
```

我们手中的碎片：

- 合约地址：`0x6b175474e89094c44da98b954eedeac495271d0f`
- 发送的数据：`0x18160ddd`
- 节点 URL：`https://eth.llamarpc.com`

现在构造一个完整的在终端运行的命令：

```bash
cast call 0x6b175474e89094c44da98b954eedeac495271d0f 0x18160ddd --rpc-url https://eth.llamarpc.com
```

### 解析结果

返回值是：

```
0x00000000000000000000000000000000000000000dab32b749369c585e17be5f
```

再次使用 `cast --to-dec` 把这个数据变成 10 进制：

```
4230270942185472370266324575
```

为什么这么大，这比全世界的钱加起来都多？

因为涉及到了 EVM 处理数字的一个核心规则：**精度（Decimals）**，我们前面也讲过。

DAI 的精度是 18 位，所以我们要挪动 18 个数字到小数点后面：

```
4,230,270,942，总共也就这么多钱大概 42 亿
```

---

## 第五部分：带参数的调用

### 查询 V 神的 DAI 余额

现在我们再来一个，带参数的调用。

比如我们查某人的余额，现在我们查一下 V 神的 DAI 余额。

**V 神地址**：`0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045`

**目标函数**：`balanceOf(address)`

### 构造 Call Data

我们需要像搭积木一样把它们拼起来。这个数据包（Call Data）由两部分组成：

- **头部（Head）**：就是函数选择器（4 字节）。
- **身体（Body）**：就是参数（这里是 V 神的地址）。

#### 步骤 1：计算函数选择器

先用 `cast keccak` 算出 `balanceOf(address)` 的哈希值：

```bash
cast keccak "balanceOf(address)"
```

`0x70a08231` 就是 `balanceOf(address)` 在 EVM 里的唯一身份证号。

#### 步骤 2：编码参数

**目标长度**：64 个字符（32 字节）。

**V 神地址**：`d8dA6BF26964aF9D7eEd9e03E53415D37aA96045`（40 个字符）。

**补零**：我们需要在地址的左边补上 24 个 0（ $64 - 40 = 24$ ）。这是因为 EVM 处理数据时，每个参数必须占满 32 字节。

#### 步骤 3：组合完整的 Call Data

```
0x70a08231000000000000000000000000d8da6bf26964af9d7eed9e03e53415d37aa96045
```

这个就是一个标准的 calldata。

### 发送请求

然后我们再使用 cast 发送出去，看看 V 神钱包到底有多少 DAI：

```bash
cast call 0x6b175474e89094c44da98b954eedeac495271d0f 0x70a08231000000000000000000000000d8da6bf26964af9d7eed9e03e53415d37aa96045 --rpc-url https://eth.llamarpc.com
```

### 结果

结果我现在得到的结果是：

```
0x0000000000000000000000000000000000000000000000000000000000000000
```

V 神一个 DAI 也没有。

这正好说明了我们刚才那套复杂的手动操作是完全成功的！你得到了一个真实的、准确的链上数据。

---

## 总结

### 1. Cast 的核心作用

Cast 是一个命令行 JSON-RPC 客户端，它将复杂的区块链交互简化为简单的终端命令。

**底层原理**：所有命令都被转换为标准的 JSON-RPC 请求，发送给以太坊节点。

### 2. 基础命令

- **查询区块号**：`cast block-number --rpc-url <RPC_URL>`
- **查询链 ID**：`cast chain-id --rpc-url <RPC_URL>`
- **16 进制转 10 进制**：`cast --to-dec <HEX_VALUE>`
- **计算 Keccak256**：`cast keccak "<STRING>"`

### 3. 与智能合约交互

**基本格式**：

```bash
cast call <CONTRACT_ADDRESS> <CALL_DATA> --rpc-url <RPC_URL>
```

**关键步骤**：

1. 使用 `cast keccak` 计算函数选择器（前 4 字节）
2. 按 32 字节（64 字符）对齐编码参数
3. 组合完整的 call data
4. 使用 `cast call` 发送请求

### 4. 精度处理

- **ETH/大部分代币**：精度 18（除以 $10^{18}$）
- **USDC/USDT**：精度 6（除以 $10^6$）
- **DAI**：精度 18（除以 $10^{18}$）

### 一句话总结

Cast 让你能够直接在命令行与以太坊节点和智能合约交互，通过手动构造 JSON-RPC 请求来查询链上数据、调用合约函数，是调试和验证想法的强大工具。
