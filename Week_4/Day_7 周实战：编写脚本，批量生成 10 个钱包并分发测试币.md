# 空投脚本实战：从钱包衍生到批量分发

本周的内容也基本学完了，我们每次第七天都是收尾。今天来做个周实战，写一个脚本可以批量生成 10 个钱包并分发测试币，相当于空投脚本。

---

## 第一部分：核心概念拆分

听起来像一个简单的循环，我们拆分一下：

1. **私钥的衍生**：如何从一个种子获取到我们要的钱包
2. **交易的原子性**：脚本（script）和合约（Contract）的 for 循环完全不同！

### HD 钱包回顾

还记得在 W1D6 学过的理论吗，HD 钱包 (BIP-32/44)？

我们今天就来使用它，只需要一个私钥，就可以衍生出无数个私钥。这个我们都明白，不记得的可以回去复习一下。

我们使用 Foundry 来生成我们的地址：

```solidity
// 伪代码
// 这一行是生成第 index 个使用 mnemonic 助记词生成的私钥
uint256 privatekey = vm.deriveKey(mnemonic, index)
// 这一行是获取这个私钥的公钥
address newWallet = vm.addr(privateKey)
```

- `index = 0` → 你的主钱包
- `index = 1` → 子钱包 1
- `index = 2` → 子钱包 2

这完全是链下的操作，纯数学使用椭圆曲线乘法的计算，不花一分钱 GAS。

---

## 第二部分：两种实现方式对比

下面使用 Foundry 有两种写法，一种是脚本里循环，一种是合约里循环。

### 方法一：在脚本写 for 循环

#### 工作原理

脚本在你电脑上本地 EVM 运行的，当你写一个循环，其实这个循环在 CPU 里跑的，但碰到 `vm.broadcast()`，你的脚本就会拿起电话，给区块打一个电话，发送一笔交易到链上去。

就像你是一个店长，告诉下面的人，给 A 送一份餐，给 B 送一份餐，一共送十份。

这样的话你想想，每次都要发送一笔交易，一共要发送 10 笔，gas fee 非常的高，而且比如第 4 个电话没打通，那么前三个人已经送过去了，也不能撤回。

#### 代码示例

```solidity
// script/AirdropScript.s.sol
contract AirdropScript is Script {
    function run() external {
        // 循环在你电脑上跑
        for (int i = 0; i < 10; i++) {
            vm.startBroadcast();
            payable(recipients[i]).transfer(1 ether);
            vm.stopBroadcast();
        }
    }
}
```

### 方法二：专门写一个分发的合约，在合约中写 for

#### 工作原理

你为了发送这 10 个交易，所以先写了一个合约，发送到链上。你在调用合约的时候会传入一个数组，这就是存放需要发送的地址清单。最后合约收到之后在合约内部进行 for 循环。

就好比刚刚的店长，这次不用一个一个打电话了，直接租了一个车，到时候告诉车上的人要送到哪，它会替你去直接送按着名单。

只发送了一笔交易，gas fee 也只是调用合约的费用。但是有个问题，当车坏了（gas 不足或者代码报错），这 10 份就一份也送不出去了，只能原路返回。

#### 代码示例

**链上合约**：

```solidity
contract Airdrop {
    function batchSend(address[] memory users) external payable {
        // 循环在链上跑
        for (uint i = 0; i < 10; i++) {
            payable(users[i]).transfer(1 ether);
        }
    }
}
```

**本地脚本**：

```solidity
contract CallAirdrop is Script {
    function run() external {
        // 把名单弄出来
        address[] memory users = new address[](10);

        vm.startBroadcast();
        airdropContract.batchSend{value: 10 ether}(users);
        vm.stopBroadcast();
    }
}
```

### 方法对比表

| 特性 | 方法一：Script 暴力循环 | 方法二：Contract 批量处理 |
| :--- | :--- | :--- |
| **循环发生地** | 本地 (Localhost) | 链上 (On-Chain) |
| **交易笔数** | N 笔 (你有多少用户就发多少笔) | 1 笔 |
| **Gas 成本** | 🔥 很高 (浪费 N 次起步价) | 🍃 较低 (最省钱) |
| **失败后果** | 部分成功，部分失败 | 要么全成功，要么全失败 |
| **适用场景** | 少量操作 (比如给 3-5 个测试号发币) | 工业级应用 (比如给 1000 人发空投) |

---

## 第三部分：使用 Ether.js 实现

结束了吗？没有，你忘了我们还有一个工具叫 ether.js 吗？我们用它也来弄一个。

### 衍生路径回顾

首先我们还是要使用助记词来衍生 10 个地址，然后通过 provider 向节点发送 10 笔交易。

对于以太坊，标准的路径长这个样子：

```
m / 44' / 60' / 0' / 0 / 0
```

这串字符看着像乱码，其实每一部分都有固定的含义：

- **m**：Master (树根/主节点)。
- **44'**：代表我们使用的是 BIP-44 标准。
- **60'**：代表以太坊 (Ethereum) 这个币种 (比特币是 0')。
- **0'**：账户索引 (Account)。你可以把它想象成银行里的"主账户"。
- **0**：链类型。通常 0 代表外部可见地址（收款用），1 代表内部找零地址。
- **0**：地址索引 (Address Index)。这不仅是最后一位，也是我们要变魔术的地方！✨

我们改变最后一位地址索引来生成新的地址。

### 生成钱包代码

来吧，使用 ether.js V6 来写代码，如下：

```javascript
import { ethers } from "ethers";

// 1. 准备助记词，永远不要泄露助记词，这只是测试用
const mnemonic = "test test test test test test test test test test test test";

// 2. 创建主节点（Master Node）
const masterWallet = ethers.HDNodeWallet.fromPhrase(mnemonic);

// 循环生成 10 个钱包，i 就是刚刚说的地址索引
console.log("正在衍生钱包...");
for (let i = 0; i < 10; i++) {
    // 关键魔法：拼接路径 m/44'/60'/0'/0/ + i
    const derivationPath = `m/44'/60'/0'/0/${i}`;
    
    // 衍生！
    const childWallet = masterWallet.derivePath(derivationPath);
    
    console.log(`第 ${i} 号钱包地址: ${childWallet.address}`);
    console.log(`第 ${i} 号私钥: ${childWallet.privateKey}`);
    console.log("------------------------");
}
```

### 发送交易代码

下一步，写脚本来从主钱包发出这 10 笔交易，还是独立的 10 次，和 Foundry 脚本是一样的。如下：

```javascript
import { ethers } from "ethers";

async function main() {
    // 假设这是你的主钱包 (Deployer)
    const wallet = new ethers.Wallet(process.env.PRIVATE_KEY, provider);

    // 生成的 10 个接收者地址 (复用刚才的逻辑)
    const recipients = [/* ... 刚才生成的 10 个地址 ... */];

    console.log("开始空投...");

    for (let i = 0; i < recipients.length; i++) {
        // 🚨 关键点：这里必须用 await
        // 我们要等交易发送出去，拿到了"快递单号 (Hash)"再发下一笔
        // 否则容易因为 Nonce 冲突导致报错 "Replacement transaction underpriced"
        
        const tx = await wallet.sendTransaction({
            to: recipients[i],
            value: ethers.parseEther("1") // 每人发 1 ETH
        });

        console.log(`第 ${i+1} 笔发送成功! Hash: ${tx.hash}`);
        
        // 可选：如果你想等这一笔彻底确认了再发下一笔（更安全，但慢）
        await tx.wait(); 
    }
}

main();
```

---

## 第四部分：高级方案 - Merkle Tree

大功告成！

又有新的问题出现了，加入你是一个项目的负责人，你要向 100,000 个用户空投，如果用脚本发送，那么你需要发 100,000 笔交易，gas 费爆炸且会让网络拥堵。

如果用合约的话，一次性又不能把 100,000 个地址全部写死在合约里，太大了部署不了。

这怎么办？别怕，现在我们才是真正的在解决实际的问题。我们想想在 W1D2 中学过的 merkle tree，派上大用场了。

### 思路转变

**原来的思路**：我一户一户送，送完为止。

**现在的思路**：我不送了，你们谁符合资格，自己到我们的服务点来领取。任何符合资格的都可以来。

现在又有个问题，来领的人怎么知道它在不在名单上？这时候就要用到 merkle tree 了。

### 工作流程

1. **链下打包**：
   在自己的电脑上，把 10 万地址作为叶子节点，生成一个 merkle tree，这棵树会算出一个根 hash 值，包含了这 10 万地址所有的指纹信息。

2. **链上验证**：
   只需要把这个 root hash 存入合约里面，成本几乎为 0，只是一个 32 字节的变量。

3. **用户领取**：
   用户来领钱的时候，它不用说拿着名单来，它只需要提供一个路径，最后计算出根节点和我们存储的对比。
   - 相等 → 给钱
   - 不相等 → 滚蛋

不需要把整个名单（list）弄上去，只需要弄一个骑缝章（Root），用户拿着自己那一页纸来（Proof），只要纸上的印记能和骑缝章对应上，就能证明用户是合法的。

### 用户领取流程

这时候又说了，用户只有自己的地址，从哪给你去弄这个 proof 来啊？

这时候我们就不得不说服务点的接待员了，工作人员有一台电脑（网页前端），这个电脑里存着那 10 万人的名单。

流程是这样的：

1. 你走到接待处（打开网页），出示身份证（连接钱包）
2. 接待员打开电脑，找到你的名字（地址）
3. 通过名单，算出一条专属于你的路径（merkle proof）
4. 你拿着这条路径，去找会计（合约）
5. 会计一验证，发现没问题，就会把钱给你

### 链下脚本

你需要安装库：

```bash
npm install merkletreejs keccak256
```

这是你的接待员，负责生成树，拿到 root 并计算 proof：

```javascript
const { MerkleTree } = require('merkletreejs');
const keccak256 = require('keccak256');
const { ethers } = require('ethers');

async function main() {
    // 1. 假设这是你的白名单 (刚才生成的 10 个钱包地址)
    const whitelistAddresses = [
        "0x5B38Da6a701c568545dCfcB03FcB875f56beddC4",
        "0xAb8483F64d9C6d1EcF9b849Ae677dD3315835cb2",
        // ... 放入你的 10 个地址
    ];

    // 2. 预处理：把地址哈希化 (变成叶子节点)
    const leafNodes = whitelistAddresses.map(addr => keccak256(addr));

    // 3. 生成 Merkle Tree
    const merkleTree = new MerkleTree(leafNodes, keccak256, { sortPairs: true });

    // 4. 拿到根 (Root) -> 这就是你要部署到合约里的东西！
    const rootHash = merkleTree.getHexRoot();
    console.log('Merkle Root:', rootHash);

    // ==========================================
    // 模拟用户领取：假设我是第一个地址，我要怎么拿 Proof？
    // ==========================================
    const claimingAddress = whitelistAddresses[0];
    const claimingLeaf = keccak256(claimingAddress); // 先把我自己哈希一下

    // 获取 Proof (接待员算出的路径)
    const hexProof = merkleTree.getHexProof(claimingLeaf);
    
    console.log('My Proof:', hexProof);
    // 输出: ['0x...', '0x...', '0x...']
    // 你稍后在前端或脚本里调用合约时，就把这个数组传进去
}

main();
```

### 链上合约

你需要安装 OpenZeppelin:
```bash
forge install OpenZeppelin/openzeppelin-contracts
```

这是你的会计，只认 root，不然不给钱：

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

// 引入这一行，省去手写验证逻辑的痛苦
import "@openzeppelin/contracts/utils/cryptography/MerkleProof.sol";

contract MerkleAirdrop {
    // 存根
    bytes32 public merkleRoot;
    
    // 防止重复领取 (记录谁领过了)
    mapping(address => bool) public hasClaimed;

    // 部署时把刚才 JS 算出来的 Root 填进去
    constructor(bytes32 _merkleRoot) {
        merkleRoot = _merkleRoot;
    }

    // 用户来领奖
    // proof: 前端/脚本算出来的那个数组
    function claim(bytes32[] calldata proof) external {
        // 1. 检查是否领过
        require(!hasClaimed[msg.sender], "Already claimed");

        // 2. 计算叶子节点 (双重哈希是标准做法，防止碰撞攻击)
        // 注意：这里我们验证的是 msg.sender，意味着必须本人来领
        bytes32 leaf = keccak256(abi.encodePacked(msg.sender));

        // 3. ⭐️ 核心验证：调用 OpenZeppelin 的 verify 函数 ⭐️
        // 它会自动帮我们算路径，看最后等不等于 merkleRoot
        bool isValid = MerkleProof.verify(proof, merkleRoot, leaf);
        require(isValid, "Invalid proof");

        // 4. 验证通过！发钱
        hasClaimed[msg.sender] = true;
        // ... 发送 ETH 或 ERC20 逻辑 ...
    }
}
```

---

## 总结

完美，我们今天学会了三种方式：

- **初级开发者**：写 for 循环挨个发币
- **中级开发者**：写个合约来一键发币
- **高级开发者**：使用 merkle tree，部署一个合约来自己领币

每一种方式都有其适用场景，选择合适的方案能大幅降低成本和复杂度。
