# Classic Vulnerability: Integer Overflow and Underflow (Although fixed in 0.8.x, principles are essential)

Today, let's look at another classic vulnerability: **Integer Overflow**.

Simply put, the integer storage space in a computer is limited. When the calculation result exceeds the range that this space can accommodate, it does not get larger, but wraps around.

Just like a car's odometer, when the reading reaches the maximum value, such as 999999, running another kilometer will cause the odometer to start counting from 000000. This is **Overflow**. Similarly, if you go backwards, starting from 0 and going back 1 results in 999999, which is **Underflow**.

To deepen our understanding of this concept, we will break it down into three steps:

## Step 1: Binary and Low-level Principles

To understand overflow, you must first accept a premise: in the computer world, containers for storing numbers have a fixed size.
In Solidity, the most commonly used unit is `uint256`. For demonstration purposes, we will use `uint8` as an example.

### Limit of the Container

`uint8` means having 8 slots to store 0s and 1s.

*   **Minimum Value**: `0000 0000`, representing 0
*   **Maximum Value**: `1111 1111`, representing 255

Imagine this is a mechanical watch that can only display three digits.

### How does Overflow happen?

Let's see what happens with `255 + 1`:

```text
  1111 1111
+ 0000 0001
-----------
1 0000 0000  -> The result is 256!
```

Because it can only save 8 bits, the highest bit is lost, and the result becomes `0000 0000`.
This is why `255 + 1 = 0`. This is **Overflow**.

Let's look at **Underflow**.
Subtract 1 from 0:

```text
  0000 0000
- 0000 0001
-----------
```

Imagine winding back the odometer from 0; it becomes 999. In binary, it turns into the maximum value for that type. The result becomes `1111 1111`, which is 255 in decimal.

If we are in a `uint8` environment and the current number is 250, and we execute the addition operation `250 + 10`.
What do you think the final result is?
Actually, it is `250 + 10 - 256 = 4`.

This is mathematically known as the **Modulo Operation**. If the computer's low-level logic is not intervened, it will wrap around just like your calculation, leaving only the remainder.

## Step 2: Solidity and EVM Handling Mechanism

Since the underlying hardware just wraps around, when writing smart contracts, we certainly don't want the money amount `255 + 1` to become 0.

Solidity experienced a huge watershed moment in handling this issue: **Version 0.8.0**.

### Before 0.8.0
Before version 0.8.0, if no external libraries were used, the code would silently overflow just like our calculation.
`250 + 10 = 4`

The transaction executes successfully, but the balance is wrong. This is the most dangerous **Silent Failure**.

### After 0.8.0
However, after version 0.8.0, the compiler added default checks.
If we write `250 + 10` for `uint8` in a version after 0.8.0, what do you think will happen?
That's right, it will cause the transaction to fail directly, `revert`. This is the default behavior of 0.8.x.

Once out of range, the compiler throws a `Panic` error and forces the entire transaction to roll back.
This means:
1.  The state will not change at all.
2.  All previous operations are voided.
3.  The gas for executing the transaction is lost, but the funds in the contract are safe.

## Step 3: Classic Attack Review - BEC TOKEN

Now that we know the principle, let's look at the famous **BEC Vulnerability** in history.
In 2018, hackers used this integer overflow vulnerability to instantly bring the token value to 0.

The following code is a simplified version of the code worth hundreds of millions of dollars:

```solidity
function batchTransfer(address[] _receivers, uint256 _value) public returns (bool) {
    uint cnt = _receivers.length; // Number of receivers
    
    // [Key Point] Calculate the total amount to be transferred: count * single transfer amount
    uint256 amount = uint256(cnt) * _value; 

    // Check if the sender's balance is sufficient to pay the total amount
    require(cnt > 0 && cnt <= 20);
    require(_value > 0 && balances[msg.sender] >= amount);

    // ... Execute transfer logic ...
    // Increase _value for each receiver's account
    // Deduct amount from msg.sender's account
}
```

**Scenario Assumption**: The hacker wants to transfer money to 2 accounts, but his own balance is almost 0.
To pass the check `require(_value > 0 && balances[msg.sender] >= amount);`, he needs to make `amount` very small.

Known `cnt = 2`, `amount` type is `uint256`.
What value should the hacker set `_value` to in order to cause the result to overflow?

We find the critical point of overflow $2^{256}$, which is roughly $1.15 \times 10^{77}$.
Since there are two people receiving transfers, we just need to divide the critical point by 2.

It becomes:
$$ \text{\_value} = \frac{2^{256}}{2} = 2^{255} $$

This is the famous attack value, which looks like this in Hex:
`0x8000000000000000000000000000000000000000000000000000000000000000`
That is, the first bit is 1, and the rest are all 0.

Let's see what happens if we pass this in:

1.  **Calculate amount**: The code executes `amount = cnt * _value`, which is $2 \times 2^{255}$. The result equals $2^{256}$, **Overflow!** `amount` instantly becomes 0.
2.  **Balance Check**: `require(balances[msg.sender] >= amount)`. Checked, and it is indeed greater than or equal to 0.
3.  **Transfer Operation**: The code continues to run, adding that astronomical `_value` to the two receivers' accounts.

Just like that, without spending almost any money, close to infinite tokens appeared out of thin air in two accounts. This is the truth behind the evaporation of 6.4 billion BEC tokens.

Since this attack is so terrible, what did developers use to prevent it before Solidity 0.8.0?

They used the `SafeMath` library, usually provided by OpenZeppelin.
Before Solidity 0.8.0, almost all contracts would write at the beginning:
`using SafeMath for uint256;`

Its function is to turn ordinary addition, subtraction, multiplication, and division into checked versions.
*   **Ordinary writing**: `a + b`. If it overflows, the result is wrong, but the transaction continues.
*   **SafeMath writing**: `a.add(b)`. If it overflows, the code will report an error internally and roll back the transaction.

Now you understand!

## Summary

Integer Overflow and Underflow are classic vulnerabilities caused by the limited number of bits computers use to store numbers. Before Solidity 0.8.0, this was like an invisible bomb: once a calculation result exceeded the range, the value would silently wrap around (e.g., 255 + 1 becomes 0), leading to serious logic errors and asset losses (like the BEC incident).

Although Solidity 0.8.0 and later versions have built-in Over/Underflow Checks, which interpret overflows as exceptions and roll back transactions by default (greatly improving security), understanding this principle remains crucial because:
1.  **Reading Legacy Code**: When auditing or maintaining contracts written before 0.8.0, you must always be alert to whether SafeMath is used.
2.  **Gas Optimization**: In 0.8.0+ versions, if you are certain that certain calculations will absolutely not overflow (such as `i++` in a loop), you can use the `unchecked { ... }` block to skip checks, thereby saving Gas.
3.  **Low-level Understanding**: Understanding binary wrapping is the foundation for mastering EVM low-level calculation logic.
