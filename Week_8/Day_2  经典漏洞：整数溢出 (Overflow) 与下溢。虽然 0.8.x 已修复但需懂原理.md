# 经典漏洞：整数溢出 (Overflow) 与下溢。虽然 0.8.x 已修复但需懂原理

我们今天来看另一个经典漏洞：**整数溢出**。

简单来说，计算机中的整数存储空间是有限的，当计算结果超出这个空间能容纳的范围，它不会变大，而是会回绕（Wrap around）。

就像汽车的里程表，当读数达到最大值，比如999999，这时候再跑一公里，里程表会从000000开始计数，这就是**溢出（Overflow）**。同理，如果倒退也是一样，从0开始倒退1，就是999999，这就是**下溢（Underflow）**。

为了深入这个概念，我们分三步来：

## 第一步：二进制与底层原理

要理解溢出，首先要接受一个设定：在计算机的世界里，存放数字的容器是有固定大小的。
在 Solidity 中，最常用的单位是 `uint256`。为了方便演示，我们使用 `uint8` 来举例。

### 容器的极限

`uint8` 意味着有 8 个格子来存放 0 和 1。

*   **最小值**：`0000 0000`，表示 0
*   **最大值**：`1111 1111`，表示 255

想象一下，这是一个只能显示三位的机械表。

### 溢出是怎么发生的？

我们来看看 `255 + 1` 会发生什么情况：

```text
  1111 1111
+ 0000 0001
-----------
1 0000 0000  -> 结果是 256！
```

因为只能保存 8 位，所以最高的一位就丢了，结果就变成了 `0000 0000`。
这就是为什么 `255 + 1 = 0`，这就是**上溢**。

我们再来看看**下溢**。
从 0 减去 1：

```text
  0000 0000
- 0000 0001
-----------
```

这时候想象从里程表 0 的地方倒转一样，它会变成 999。在二进制里面，它会变成该类型的最大值，结果变成了 `1111 1111`，也就是十进制的 255。

如果我们在 `uint8` 环境下，当前数字是 250，如果我们执行加法操作 `250 + 10`。
你觉得最终结果是多少？
其实就是 `250 + 10 - 256 = 4`。

这在数学上被称为**取模运算**。计算机底层如果不加干预，就会像你算出来的一样，直接绕过去，只留下余数。

## 第二步：Solidity 与 EVM 的处理机制

既然底层硬件是这样只会转圈，我们在写智能合约时，肯定不希望钱数 `255 + 1` 变成 0。

Solidity 在处理问题上，经历了一个巨大的分水岭：**0.8.0 版本**。

### 0.8.0 之前
在 0.8.0 版本之前，如果不使用额外的库，代码就会像我们刚才算的那样，默默地溢出。
`250 + 10 = 4`

交易执行成功，但是余额错误了，这是最危险的**静默失败**。

### 0.8.0 之后
但是在 0.8.0 版本之后，编译器默认增加了检查。
如果在 0.8.0 之后的版本，我们写 `uint8` 的时候写了 `250 + 10`，这时候你觉得会发生什么？
没错，会让交易直接失败，`revert`。这就是 0.8.x 的默认行为。

一旦超出范围，编译器会抛出一个 `Panic` 错误，并强制回滚整个交易。
这就意味着：
1.  状态完全不会改变。
2.  之前的操作全部作废。
3.  损失掉执行交易的 gas，但是合约里的资金是安全的。

## 第三步：经典攻击复盘 BEC TOKEN

既然我们知道了原理，那我们就得看看历史上著名的 **BEC 漏洞**。
2018 年的时候，黑客利用这个整数溢出漏洞，瞬间让代币价值归 0。

以下代码是价值数亿美元的代码简化版：

```solidity
function batchTransfer(address[] _receivers, uint256 _value) public returns (bool) {
    uint cnt = _receivers.length; // 接收者的人数
    
    // [关键点] 计算需要转出的总金额：人数 * 单人转账金额
    uint256 amount = uint256(cnt) * _value; 

    // 检查转账发起人的余额是否足够支付总金额
    require(cnt > 0 && cnt <= 20);
    require(_value > 0 && balances[msg.sender] >= amount);

    // ... 执行转账逻辑 ...
    // 给每个 receiver 的账户增加 _value
    // 从 msg.sender 的账户扣除 amount
}
```

**场景假设**：黑客要给 2 个账户转账，但他自己的余额几乎为 0。
为了通过 `require(_value > 0 && balances[msg.sender] >= amount);` 这个检查，他需要把 `amount` 变得非常小。

已知 `cnt = 2`，`amount` 类型是 `uint256`。
黑客应该把 `_value` 设置为一个什么样的值才能导致结果溢出？

我们找到溢出的临界点 $2^{256}$ 大概就是 $1.15 \times 10^{77}$。
因为有两个人接受转账，所以我们只需要把临界点除以 2。

变成：
$$ \text{\_value} = \frac{2^{256}}{2} = 2^{255} $$

这就是那个著名的攻击数值，在 Hex 中它长这样：
`0x8000000000000000000000000000000000000000000000000000000000000000`
也就是第一位为 1 ，后面的全是 0。

我们看看如果传进去这个会发生什么：

1.  **计算 amount**：代码执行 `amount = cnt * _value` 也就是 $2 \times 2^{255}$，结果等于 $2^{256}$ ，**溢出！** `amount` 瞬间变成了 0。
2.  **余额检查**：`require(balances[msg.sender] >= amount)`，检查了一下，确实大于等于 0。
3.  **转账操作**：代码继续运行，给两个接收者的账户加上了 `_value` 那么大的天文数字。

就这样，几乎没花钱，让两个账户凭空出现了接近无限的代币，这就是 BEC 64 亿代币蒸发的真相。

既然这种攻击这么可怕，那么在 Solidity 0.8.0 之前，开发者是使用什么来防止的呢？

就是使用 `SafeMath` 这个库，通常由 OpenZeppelin 提供。
在 Solidity 0.8.0 之前，几乎所有合约都会在开头写上：
`using SafeMath for uint256;`

它的作用就是把普通的加减乘除，变成带检查的版本。
*   **普通写法**：`a + b` 如果溢出，结果错误，交易还能继续。
*   **SafeMath 写法**：`a.add(b)` 如果溢出，代码内部会报错并回滚交易。

这下就明白了吧！

## 总结

整数溢出（Overflow）与下溢（Underflow）是由于计算机存储数字的位数有限导致的经典漏洞。在 Solidity 0.8.0 之前，这就像是一个隐形炸弹，一旦计算结果超出范围，数值会悄无声息地回绕（如 255 + 1 变为 0），导致严重的逻辑错误和资产损失（如 BEC 事件）。

虽然 Solidity 0.8.0 之后已经内置了溢出检查（Over/Underflow Checks），默认会在溢出时抛出异常并回滚交易，从而极大地提高了安全性。但理解这一原理依然至关重要，因为：
1.  **阅读旧代码**：当你审计或维护 0.8.0 之前的合约时，必须时刻警惕是否使用了 SafeMath。
2.  **Gas 优化**：在 0.8.0+ 版本中，如果你确定某些计算绝对不会溢出（比如循环中的 i++），可以使用 `unchecked { ... }` 块来跳过检查，从而节省 Gas。
3.  **底层理解**：理解二进制回绕是掌握 EVM 底层计算逻辑的基础。
