# Classic Vulnerability: Reentrancy Attack Principle and Protection

This week we enter **Contract Security Week**, analyzing some typical contract security cases.
Today we analyze the most famous chapter in the history of Web3 security — **Reentrancy Attack**.
This is not only a technical vulnerability, but also a major historical event that led to the ETH hard fork and the formation of the two worlds of ETH and BTC.

## 1. Core Principle: Recursion and "The Carbine"

Let's explore this vulnerability step by step. First, we need to understand how this "carbine" (counter-attack) is formed. The core principle is **Recursion**.

In Solidity, when a contract sends ETH to another contract, its execution **control** is transferred to the receiver.

### Scenario Simulation
Imagine this scenario:
1.  **Initial State**: User A has 100 units of money in the Bank contract.
2.  **Trigger Attack**: User A (actually a malicious contract) calls `withdraw()` to request money.
3.  **Bank Check**: The bank checks the balance and confirms A has 100 units.
4.  **Transfer Starts**: The bank transfers 100 units to Contract A.
5.  **The "Carbine"**: Here comes the critical part! At the moment A receives the 100 units, User A's contract automatically triggers a special function (like `fallback` or `receive`).
6.  **Recursive Call**: In this function, User A does not end the transaction, but instead sends another withdrawal request to the Bank contract (at this time, the bank hasn't had time to clear A's balance).
7.  **Transfer Again**: The Bank contract sees: "A still has 100 units", so it continues to transfer 100 units to him...

This operation of "re-entering" before the logic execution is completed is a **Reentrancy Attack**.

---

## 2. The DAO Hack: A Vulnerability that Changed History

In The DAO event of 2016, attackers utilized similar code logic. The simplified vulnerability code looks like this:

```solidity
// WARNING: This code contains a vulnerability!
contract VulnerableBank {
    mapping(address => uint) public balances;

    function withdraw() public {
        uint amount = balances[msg.sender];
        require(amount > 0);

        // 1. Send funds (Control is transferred to the attacker at this point)
        // Attackers use the property that msg.sender.call triggers their contract code,
        // repeatedly entering withdraw until the contract is drained.
        (bool success, ) = msg.sender.call{value: amount}(""); 
        require(success);

        // 2. Update balance (Unfortunately, if reentrancy occurs, this line will never run)
        balances[msg.sender] = 0;
    }
}
```

### Why does updating the balance after sending funds lead to serious consequences?

In the world of smart contracts, code is executed sequentially. The logic is as follows:

1.  **Query**: The contract sees you have 100.
2.  **Send Money**: The contract gives you the money first. Note that at this time, the contract hasn't run the next "deduction" action, so your balance record is still 100.
3.  **Interruption**: The moment you receive the money, your malicious contract immediately calls `withdraw` again through the `fallback` function.
4.  **Loop**: The Bank contract checks again and finds you "still have" 100, so it transfers another 100 to you.

This is like withdrawing money from an ATM: the moment the money comes out, you use the 0.1-second gap before the machine updates the bill to press the withdraw button again and take the money out. The premise of this attack is — **the ATM handed over control before confirming the bill**.

Even if the code runs fast, as long as it hands over control to you (i.e., executes the fund sending operation) before modifying the balance, you can control the fund flow. At this time, it is in an **inconsistent state**, like a forgetful teller who hands the money out the window and is pulled by you to withdraw another sum before having time to modify the ledger.

---

## 3. Why is `call` Dangerous?

In Solidity, there are multiple ways to send ETH, such as `transfer`, `send`, `call`.
But `call` is the most commonly used and also the most prone to reentrancy.

*   **Control Transfer**: When you use `msg.sender.call{value: amount}("")`, Ethereum not only transfers money but also passes the "baton" of execution rights to the receiver.
*   **Malicious Callback**: If the receiver is a contract itself, it will immediately trigger its own `fallback()` or `receive()` function. The hacker writes in this function: `Bank.withdraw()`.

---

## 4. Defense Mechanisms

### First Line of Defense: Checks-Effects-Interactions (CEI) Pattern

We need to change the above logic and switch to a "Bookkeep First, Transfer Later" method.

1.  **Checks**:
    ```solidity
    require(balances[msg.sender] >= amount); // Confirm if there is money left
    ```
2.  **Effects**:
    ```solidity
    balances[msg.sender] -= amount; // Record in the ledger first, balance is deducted even if transfer doesn't happen
    ```
3.  **Interactions**:
    ```solidity
    (bool success, ) = msg.sender.call{value: amount}(""); // Send money out at the very end
    require(success); // Check if transfer was successful
    ```
This pattern of updating state first and interacting later is called the **Checks-Effects-Interactions** pattern in the security field.

**Question**: What if we booked it, but the transfer failed?
**Answer**: Don't worry. Ethereum transactions have **atomicity**. This means that in every transaction, all operations either all succeed or all fail. We add `require(success)` at the end to check if the transfer was successful. If it fails, the entire operation (including the previous deduction) will be rolled back completely.

### Second Line of Defense: Reentrancy Guard

Sometimes code logic is too complex to strictly follow the "Check-Effect-Interaction" pattern, or it's hard to distinguish the order. What to do?
At this time, we take out our second magic weapon: **Reentrancy Guard**.

It's like locking the door immediately after entering the bathroom. As long as you don't come out, no one outside can come in no matter how they knock.

The code implementation is roughly as follows:

```solidity
bool internal locked;

modifier noReentrant() {
    require(!locked, "No reentrancy"); // Check if the door is locked
    locked = true;                     // Enter and lock
    _;                                 // Execute business logic (e.g., withdraw money)
    locked = false;                    // Finish and unlock
}
```

Suppose a hacker wants to call this function again during `_;` (execution of business logic), can he succeed?
Obviously not. He can come in smoothly, but because of the lock `require(!locked)`, he is blocked, so the contract will `revert` due to multiple entries.

---

## 5. Advanced Discussion: Cross-function Reentrancy

Let's look at: **Cross-function Reentrancy**.
The reentrancy lock we learned before is usually added to a single function. But if your contract has multiple functions sharing a variable, and you only locked one of them, the attacker will "sneak in" from another unlocked function.

### Vulnerability Example

```solidity
contract VulnerableBank {
    mapping (address => uint) public balances;
    bool internal locked;

    modifier noReentrant() {
        require(!locked, "No reentrancy");
        locked = true;
        _;
        locked = false;
    }

    // 1. Withdraw function: Locked, looks safe?
    // Note: This violates the CEI pattern, sending money before updating balance
    function withdraw() public noReentrant {
        uint amount = balances[msg.sender];
        
        // A. Send funds (Control is transferred to the attacker at this point)
        (bool success, ) = msg.sender.call{value: amount}(""); 
        require(success);

        // B. Update balance (Only executes after A finishes)
        balances[msg.sender] = 0; 
    }

    // 2. Transfer function: Oops, forgot to lock!
    function transfer(address to, uint amount) public {
        if (balances[msg.sender] >= amount) {
            balances[to] += amount;
            balances[msg.sender] -= amount;
        }
    }
}
```

**Attack Path**:
Suppose there are 100 ETH in the account.
1.  Call `withdraw()`.
2.  Program runs to **Line A**, sends 100 ETH to you.
3.  Your contract triggers the `fallback` function.
4.  In `fallback`, you **no longer** call `withdraw` (because it's locked), but call `transfer`.
5.  `transfer` is unlocked! It can execute normally. At this time, your balance hasn't been cleared (because Line B in `withdraw` hasn't been executed yet).
6.  You transfer this 100 ETH to another account of yours via `transfer`.
7.  `transfer` ends, returns to `withdraw`, and finally clears the balance.
8.  **Result**: You got 100 ETH in cash, and your other account has an extra 100 ETH deposit. The bank lost twice as much.

**Lesson**: When we set a reentrancy lock, it must be **globally effective**, or cover all functions that read/write shared states. If you only lock the front door and not the back window, you will still be robbed.

---

## 6. Industrial Grade Defense: OpenZeppelin's Gas Saving Trick

Although the principle of the lock we wrote ourselves is simple, it is easy to make mistakes.
In real development, almost everyone directly inherits OpenZeppelin's `ReentrancyGuard`.

Here is an interesting detail. Usually, we think using `bool` as a switch for the lock is the most direct:
*   `false (0)` = Unlocked
*   `true (1)` = Locked

But OpenZeppelin implements it this way:

```solidity
// OpenZeppelin's ReentrancyGuard.sol
abstract contract ReentrancyGuard {
    uint256 private constant _NOT_ENTERED = 1;
    uint256 private constant _ENTERED = 2;

    uint256 private _status;

    constructor() {
        _status = _NOT_ENTERED;
    }

    modifier nonReentrant() {
        require(_status != _ENTERED, "ReentrancyGuard: reentrant call");
        _status = _ENTERED;  // Lock: change 1 to 2
        _;
        _status = _NOT_ENTERED; // Unlock: change 2 back to 1
    }
}
```

It specifically avoids `0` and switches between `1` and `2`. Why?

### EVM Gas Optimization Trick

This is an EVM low-level money-saving trick (Gas refund):
1.  **0 -> Non-0**: Changing a storage slot from "empty" to "valued" consumes very high Gas (about 20,000 gas), like reclaiming wasteland.
2.  **Non-0 -> Non-0**: Modifying a storage slot that already has a value consumes much less Gas (about 2,900 gas).

If it is `bool`, the unlocked state is usually `false (0)`. Locking it every time turning it into `1` will consume high "reclamation fees".
However, switching between `1` and `2`, each time is a hot update, which can save a lot of Gas.

---

## 7. Complete Example: Attack Contract and Secure Contract

### Attack Contract Example

Here is a complete example of a reentrancy attack:

```solidity
// Attacker Contract
contract Attacker {
    VulnerableBank public bank;
    
    constructor(address _bankAddress) {
        bank = VulnerableBank(_bankAddress);
    }
    
    // Initiate Attack
    function attack() external payable {
        // Deposit some ETH first
        bank.deposit{value: msg.value}();
        // Then start the withdrawal attack
        bank.withdraw();
    }
    
    // fallback function: automatically triggered when receiving ETH
    fallback() external payable {
        // If the bank still has money, continue to withdraw
        if (address(bank).balance >= 1 ether) {
            bank.withdraw();
        }
    }
    
    // Extract attack proceeds
    function getBalance() public view returns (uint) {
        return address(this).balance;
    }
}
```

### Secure Bank Contract Implementation

Here is a secure implementation using the CEI pattern and OpenZeppelin Reentrancy Lock:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/security/ReentrancyGuard.sol";

contract SecureBank is ReentrancyGuard {
    mapping(address => uint) public balances;
    
    event Deposit(address indexed user, uint amount);
    event Withdraw(address indexed user, uint amount);
    
    // Deposit function
    function deposit() external payable {
        require(msg.value > 0, "Must deposit some ETH");
        balances[msg.sender] += msg.value;
        emit Deposit(msg.sender, msg.value);
    }
    
    // Secure withdraw function: Uses CEI pattern + Reentrancy Guard
    function withdraw() external nonReentrant {
        uint amount = balances[msg.sender];
        
        // 1. Checks: Check balance
        require(amount > 0, "Insufficient balance");
        
        // 2. Effects: Update state first
        balances[msg.sender] = 0;
        
        // 3. Interactions: Transfer at the end
        (bool success, ) = msg.sender.call{value: amount}("");
        require(success, "Transfer failed");
        
        emit Withdraw(msg.sender, amount);
    }
    
    // Query contract balance
    function getContractBalance() public view returns (uint) {
        return address(this).balance;
    }
}
```

---

## 8. Reentrancy Protection Best Practices

### ✅ Recommended Practices

1. **Always Follow the CEI Pattern**
   - Checks: Verify conditions
   - Effects: Update state variables
   - Interactions: Call external contracts or transfer funds

2. **Use OpenZeppelin's ReentrancyGuard**
   ```solidity
   import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
   
   contract MyContract is ReentrancyGuard {
       function sensitiveFunction() external nonReentrant {
           // Your code
       }
   }
   ```

3. **Prefer `transfer()` or `send()` (Where Applicable)**
   - These two functions only forward 2300 gas, which is insufficient to execute complex reentrancy attacks
   - But note: It may fail in some cases (e.g., receiver is a contract and fallback function consumes more gas)

4. **Use Pull Payment Pattern**
   - Do not actively push funds, but let users withdraw them themselves
   ```solidity
   mapping(address => uint) public pendingWithdrawals;
   
   function withdraw() external {
       uint amount = pendingWithdrawals[msg.sender];
       pendingWithdrawals[msg.sender] = 0;
       payable(msg.sender).transfer(amount);
   }
   ```

### ❌ Practices to Avoid

1. **Do Not Make External Calls Before State Updates**
   ```solidity
   // ❌ Bad Example
   msg.sender.call{value: amount}("");
   balances[msg.sender] = 0;
   ```

2. **Do Not Only Lock Partial Functions**
   - If multiple functions share state, either lock all of them or ensure all follow the CEI pattern

3. **Do Not Ignore Cross-Contract Reentrancy**
   - Attackers may achieve reentrancy by calling other contracts you depend on

---

## 9. Summary

Reentrancy attack is one of the most classic and dangerous vulnerabilities in smart contract security. Understand its core points:

1. **Root Cause**: Handing over control before state updates
2. **Attack Method**: Using `fallback`/`receive` function for recursive calls
3. **Defense Strategy**:
   - CEI Pattern (Preferred)
   - Reentrancy Lock (Auxiliary)
   - Pull Payment Pattern (Specific scenarios)

Remember: **Bookkeep First, Transfer Later**. This is the simplest and most effective principle to prevent reentrancy attacks.

---

## 10. Further Reading

- [The DAO Hack Detailed Analysis](https://www.gemini.com/cryptopedia/the-dao-hack-makerdao)
- [OpenZeppelin ReentrancyGuard Source Code](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol)
- [Solidity Official Docs: Security Considerations](https://docs.soliditylang.org/en/latest/security-considerations.html)
- [Consensys Smart Contract Best Practices](https://consensys.github.io/smart-contract-best-practices/)
