# W7D3: Slot Packing 深度解析

## 前言

今天真的要上点强度了，来学习 **Slot Packing**（槽位打包）技术。

## 一、Memory vs Storage 回顾

### Memory（内存）
Memory 就像教室里的**黑板**：
- 你在上面计算
- 用完之后会被擦干净
- **成本低廉**，随擦随用

### Storage（存储）
Storage 像是一个**永久储物箱**：
- 放进去的东西会被永久保存
- 哪怕 100 年之后节点都会帮你存储
- 只要还有节点在运行

## 二、以太坊保险箱的规则

### 核心规则

1. **固定大小**：每个保险箱（slot）大小是固定的
   - 只有 **32 字节**，不多不少
   - 等于 **256 位**

2. **开箱昂贵**：
   - `sstore` 写入因为要全网同步，消耗 **22,100 gas**
   - `sload` 读取也比内存操作贵得多，消耗 **2,100 gas**

3. **按个收费**：
   - 不管你放入一张纸，还是放入一斤黄金，收费都一样
   - 只要占用了新箱子，以太坊就收你一个的钱

### 什么是 Slot Packing？

**Slot Packing** 就是为了节省租金，拼命把东西放在一个保险箱里面。

**举例**：
- 有两个小东西 `uint128`
- 把它们放在同一个箱子里
- **好处**：
  - 存的时候便宜
  - 取出来的时候可以一并取出来
  - 一箭双雕！

## 三、Yul 层面的数据打包

### 难点

在 Yul 层面怎么把数据挤进去？

### Solidity 的存储策略

Solidity 非常聪明，它会像人一样存储数据，所以它是**从右到左**，也就是**从低位到高位**填充 slot。

这和我们人类写数字是一样的：
- 我们写数字都是从大到小
- 写一个 `1` 代表个位
- 写一个 `2` 在 `1` 左边变成 `21`，代表十位
- 以此类推

### 计算机中的位表示

在计算机的世界里：
- **最右边**代表**低位**（Least Significant Bits, LSB），也就是数值最小的地方
- Solidity 为了节省 GAS，会尽量把东西往低处，也就是**右边**去塞
- 就像一个放羽毛球的盒子一样，竖着放进去羽毛球就会自动落到最下面

### 示例合约

假设我们有这样一个合约：

```solidity
contract Packing {
    uint64 public a;
    uint64 public b;
    uint128 public c;
    // 64 + 64 + 128 = 256，正好占了 slot 0 的位置
}
```

在 EVM 眼中，**Slot 0** 中的位置是这样的：

```
┌─────────────┬─────────────┬─────────────┐
│  c (128位)  │  b (64位)   │  a (64位)   │
│   左边      │   中间      │   右边      │
└─────────────┴─────────────┴─────────────┘
```

- 变量 `a` 被放在了**最右边**
- 变量 `b` 放**中间**
- 变量 `c` 放在了**最左边**

## 四、位操作三大法宝

如果要真的理解 `sload` 和 `sstore` 的位操作，我们需要解决一个问题：**如何把混在一起的数据拆开？**

比如在 Yul 中写了：
```yul
let data := sload(0)  // 读取了 Slot 0 的全部数据
```

现在 `data` 中同时包含了 `a`、`b`、`c` 三个值。

**问题**：我们只想拿到 `b` 的值怎么办？

**答案**：使用操作码从 `data` 中提取 `b` 的值。

### 1. Mask（掩码/模具）

**比喻**：就像一个透明的玻璃板

想象场景：
- 我们有一个 256 位的纸带，模拟 slot
- 我们拿一个透光的玻璃板，相当于给纸带上一个滤镜

**规则**：
- 在 `1` 的位置，玻璃板是**透明**的，可以直接看到数据，所以数据会**原样保留**
- 在 `0` 的位置，玻璃板被**涂黑**了，什么都看不到，也就只显示 `0`

**效果**：
- 在 `1` 的位置保留原始的值
- 在 `0` 的位置把数据都变成 `0`

### 2. SHL 和 SHR（位移操作）

这是英文的缩写：
- `shl` = **Shift Left**，也就是向左推
- `shr` = **Shift Right**，也就是向右推

#### SHL 示例

```yul
shl(x, y)  // 把 y 向左推动 x 格
```

**举例**：
- 原来的数据是 `0011 0001`
- 使用指令 `shl(4, 00110001)`
- 左边的 `0011` 被推走了，就消失了
- 原来右边 `0001` 的位置空出来了，会被填充 `0`
- 结果变成了 `0001 0000`

#### SHR 示例

`shr` 也是同理，不过是向右推数据。

### 3. AND（与操作）

```yul
and(mask, data)
```

用**模具** `mask` 盖住数据 `data`，然后把不需要的数据切掉，也就是板子没挡住的地方涂上 `0`。

**举例**：
- `mask` 是 `0000 1111`
- `data` 是 `1111 0101`
- 使用 `and(mask, data)`
- `mask` 中 `1` 代表保留，`0` 代表覆盖为 `0`
- 结果：`data` 变成了 `0000 0101`

## 五、读取操作：提取变量 b

有了这三个操作码指令，我们就能解决问题了！

### 步骤 1：右移（SHR）

我们要把 `b` 拿出来，因为它在中间，所以需要先把右边的 `a` 给推走，让 `b` 处于最右边的位置。

```yul
let data_s = shr(64, data)  // 因为 a 占 64 位，所以我们推走 64 位
```

现在 `data_s` 变成了：`[0...0 | c | b]`

### 步骤 2：掩码（AND）

然后把左边不需要的数据切掉，我们使用 `and` 来操作。

因为 `b` 是 64 位的，所以我们需要 64 个 `1` 来保证它不被覆盖。

**生成 Mask 的方法**：

方法 1：直接写 16 进制
```yul
0xFFFFFFFFFFFFFFFF  // 16 个 F，每个 F 代表 4 个 1
```

方法 2：使用位移技巧（推荐）
```yul
(1 << 64) - 1
```

**为什么这样写？**

这是一个经典用法，来快速生成一段 `1`。

举个例子：
- `1000` 其实就是 `1 << 3`，`1` 放在了第四位
- 减去 `1` 后，得 `0111`
- 成功让 3 位变成了 `1`

所以：
- `1 << 64` 就是 `1` 后面有 64 个 `0`
- 减去 `1` 之后就是一个 `0` 后面有 64 个 `1`

很简单吧！

### 完整代码

```yul
let b := and((1 << 64) - 1, shr(64, data))
// c 的地方是 0，所以被覆盖了
// 只有最后 64 位留了下来，也就是 b 的值
```

合并到一个公式就是：
```yul
let b := and((1 << 64) - 1, shr(64, data))
```

搞定！✅

## 六、写入操作：修改变量 b

### 为什么写入更复杂？

读取虽然麻烦，但是不会破坏数据。**存储才是真正的 gas 杀手**。

现在假设我们延续上面的合约，要把 `b` 的值修改为 `new_value`，不改变 `a` 和 `c`。

### EVM 的 SSTORE 特性

EVM 的 `sstore(key, value)` 非常粗暴，如果直接使用的话会**覆盖 256 位的全部 slot**。

如果你写入：
```yul
sstore(0, new_value)
```

那么整个 `slot 0` 只剩下 `new_value` 这个值了，`a` 和 `c` 都消失了！

### 正确的写入流程

为了修改这个操作，我们需要一个流程：

```
先读取 → 再修改 → 最后写入
```

**比喻**：假设有一个教室黑板，上面有一些数据，我们写入的时候需要先把 `b` 的值擦除了，然后再写入新的值，不然直接写上去会变成重叠，难以辨认。

### 详细步骤

#### 步骤 1：读取整个值

```yul
let data := sload(0)
```

#### 步骤 2：修改（擦除 + 写入）

我们必须有一个**反向的模具**来保留数据，如下：

```
┌─────────────┬─────────────┬─────────────┐
│  11...1     │  00...0     │  11...1     │
│  c (保留)   │  b (擦除)   │  a (保留)   │
└─────────────┴─────────────┴─────────────┘
```

**生成反向 Mask**：

我们刚刚不是生成了一个 mask 吗 `(1 << 64) - 1`，把最右边的 64 位保持原样。

现在我们需要：
1. 先把这个 64 位挪到 `b` 的地方
2. 然后取反，把其他地方保持原样，把中间的 `b` 覆盖掉

**NOT 指令**：
- `not(x)` 会把 `x` 里面的 `0` 变成 `1`，`1` 变成 `0`，也就是取反

**代码**：
```yul
let mask := (1 << 64) - 1              // 00...00 | 00...00 | 11...11
let mask_not := not(shl(64, mask))     // 11...11 | 00...00 | 11...11
```

这里有两个操作：
1. 向左移动（`shl`）
2. 取反（`not`）

现在 `mask_not` 的值就是 `[11...1 | 00...0 (b) | 11...1]`，其中 `0` 占据 `b` 位置的 64 位。

**擦除 b 的值**：
```yul
let data_s := and(mask_not, data)
```

现在 `data_s` 的值变成了：

```
┌─────────────┬─────────────┬─────────────┐
│  c (128位)  │  00...00    │  a (64位)   │
│   左边      │   中间      │   右边      │
└─────────────┴─────────────┴─────────────┘
```

使用 mask 保留了 `a` 和 `c` 的值，`b` 的值被覆盖了。

#### 步骤 3：填入新值

接下来我们需要填入新的值，完成新数值的拼接。

`new_value` 一开始的时候也在最右边，所以我们需要使用 `shl` 向左推它和 `b` 的值对齐：

```yul
let shifted_new_value := shl(64, new_value)
```

现在变成了：`[00...00 | new_value | 00...00]`

我们现在有两条纸带：
```
纸带 1:  c |     0     | a   // 中间透明，两边有数据
纸带 2:  0 | new_value | 0   // 两边透明，中间有数据
```

现在我们需要把这两个叠在一起，生成完整的新纸带。

**OR 指令**：

在位运算中，两个互不冲突的数据**合并**在一起，通常使用 `or` 指令。

就是把两个纸带叠加到一起，透明的地方被另一个不透明的地方覆盖。

```yul
// 3. 合并：把两个纸带叠在一起，不透明的地方合并
let result := or(data_s, shifted_new_value)

// 4. 写入：把值放回保险箱
sstore(0, result)
```

**大功告成！** 🎉

## 七、完整代码示例

### 读取变量 b

```yul
let data := sload(0)
let b := and((1 << 64) - 1, shr(64, data))
```

### 修改变量 b

```yul
// 1. 读取
let data := sload(0)

// 2. 擦除 b 的值
let mask := (1 << 64) - 1
let mask_not := not(shl(64, mask))
let cleared_data := and(mask_not, data)

// 3. 准备新值
let shifted_new_value := shl(64, new_value)

// 4. 合并
let result := or(cleared_data, shifted_new_value)

// 5. 写入
sstore(0, result)
```

## 总结

通过本文，我们学习了：

1. **Memory vs Storage** 的区别
2. **Slot Packing** 的原理和优势
3. **位操作三大法宝**：Mask、SHL/SHR、AND
4. **读取操作**：如何从打包的 slot 中提取单个变量
5. **写入操作**：如何在不破坏其他数据的情况下修改单个变量

掌握这些技巧，你就能在 Yul 层面实现高效的 gas 优化！💪
