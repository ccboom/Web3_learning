# Day 5: 位运算技巧 - 利用 shl, shr, and, or 进行数学计算优化

## 前言

终于来到了第五天，之前汇编内存和存储都被拿下了，今天我们来学习微观世界——比特位。

在高级语言中，我们习惯使用 `*` 做乘法，`/` 做除法，但是在 EVM 底层里面，数学运算是非常昂贵的，消耗 gas 比较多。作为优化大师，我们必须学会使用**位运算**来替代某些数学运算，从而节省 Gas。

## 一、位移运算：shl 和 shr

我们先来讲最常用的两个：`shl` 和 `shl`。

### 1.1 十进制类比

想象一下我们在 10 进制的时候：

- 如果数字 `1` 往左移动了一位，那么就是在右边补一个 `0`，变成 `10`，数字扩大了 10 倍
- 如果数字 `1000` 往右移动了一位，那么就是整体往右边移动一位，变成 `100`，最右边的 `0` 被消除了,数字缩小了 10 倍

在二进制里面道理是相同的，只不过倍数发生了变化。

### 1.2 左移运算 shl（Shift Left）

我们举个最简单的例子：`3`

- 十进制：`3`
- 二进制：`0011`（为了方便观看只写后四位）

在 Yul 中，`shl` 的语法是 `shl(x, y)`，我们讲过。

**示例 1：`shl(1, 3)`**

把 `3` 往左移动一位：

```
原始：0011 (3)
左移：0110 (6)
```

左移后变成了 `0110`，这时候十进制变成了 `2 + 4 = 6`。

发现了什么没有？变成了 `3` 的 2 倍！

**示例 2：`shl(2, 3)`**

```
原始：0011 (3)
左移：1100 (12)
```

变成了 `1100`，`4 + 8 = 12`，变成了 `3` 的 4 倍。

**规律总结：**

```
shl(n, y) 相当于 y × 2^n
```

这时候你就能明白，如果计算 `× 2`、`× 4` 等乘法时，`shl` 比 `mul` 指令更加节省 Gas。

### 1.3 右移运算 shr（Shift Right）

既然左移是乘以 2，那么我们来看看右移。

我们以 `12` 举例：`1100`

**示例 1：`shr(1, 12)`**

```
原始：1100 (12)
右移：0110 (6)
```

变成 `0110`，`2 + 4 = 6`

**示例 2：`shr(2, 12)`**

```
原始：1100 (12)
右移：0011 (3)
```

会变成 `0011`，`2 + 1 = 3`

**示例 3：`shr(3, 12)`**

```
原始：1100 (12)
右移：0001 (1)
```

变成了 `0001`，变成了 `1`

**规律总结：**

每向右移动一位，都是除以 2。

```
shr(n, y) 相当于 y / 2^n（向下取整）
```

## 二、AND 运算：高效的取模与掩码

接下来我们要讲一下强大的 `and`。

在 Solidity 优化中，`and` 经常被用来代替 `mod` 操作，或者用来清洗数据（Masking）。

### 2.1 AND 运算规则

`and` 我们在前几天也讲过，其实就是当两个位都是 `1` 的时候，结果才是 `1`，否则结果都是 `0`。

你可以想象成一个过滤器，只有你在掩码里允许的位置（`1`），原始数据才能显示出来。

### 2.2 使用 AND 代替取模运算

假设我们现在想计算 `13 % 4`，普通的做法是使用 `mod` 指令，但是我们是高手，所以使用 `and`。

```
13 的二进制：1101
3 的二进制： 0011

执行运算：
  1 1 0 1
& 0 0 1 1
---------
  0 0 0 1
```

结果是 `1`，没毛病！

**规律总结：**

```
x % 2^n 等价于 x & (2^n - 1)
```

> **注意**：这里掩码应该是 `2^n - 1`，在上面的例子中，`13 % 4` 应该使用 `13 & 3`（因为 `4 = 2^2`，所以掩码是 `2^2 - 1 = 3`）

这就是为什么我们在以太坊底层和很多高性能编程中喜欢使用 2 的幂次方来做数据分块或者容量限制，因为可以用极快且节省 Gas 的 `and` 运算来替代昂贵的取模运算。

## 三、OR 运算：数据打包

现在我们手里有了 `shr`、`shl` 和 `and`，我们要讲另一个：`or`。

这个技巧是关于组合的。

### 3.1 变量打包的意义

Solidity 中为了节省存储（storage）费用，我们尽量把小的数字压缩到一个 slot 里面，这个过程叫**变量打包**。

### 3.2 OR 运算规则

`or` 的规则很简单，只要对应位置有一个 `1`，结果就是 `1`。

### 3.3 打包示例

我们来用实例解释一下：

我们要把两个小数字放到一个字节里面：

```
数字 A = 3 = 0000 0011
数字 B = 4 = 0000 0100
```

我们想把 B 放在高位，A 放在低位。

那这时候应该先把 B 挪到左侧的高位，然后再使用 `or` 来进行合体：

```
步骤 1：shl(4, B) = 0100 0000
步骤 2：or(A, B_shifted)

  0 1 0 0 0 0 0 0  (B 左移后)
| 0 0 0 0 0 0 1 1  (A)
------------------
  0 1 0 0 0 0 1 1
```

先使用 `shl(4, B)` 再使用 `or(A, B_shifted)` 得到以上结果。

那么结果就是 `0100 0011`，十进制是 `1 + 2 + 64 = 67`。

成功地把两个数字 `3` 和 `4` 压缩进一个数字 `67` 中！


这意味着我们可以少写一次 `sstore`，节省大量 Gas！

### 3.4 解包操作

打包之后如果要得到原来的值，那就要解包。

现在我们从合约中读取出了 `0100 0011`（即 `67`）。

**提取低位（A）：**

我们先要还原 A，只取后四位。

所以我们需要使用 `and`，用 `0000 1111` 来充当 mask 来取后四位的值。

```
使用 and(67, 15)，因为 0000 1111 的十进制值是 15

  0 1 0 0 0 0 1 1
& 0 0 0 0 1 1 1 1
-----------------
  0 0 0 0 0 0 1 1
```

取出来的结果就是 `0000 0011`，结果是 `3`，正确！

**提取高位（B）：**

那我们要取高位怎么办？

这时候就不需要用 `and` 了，直接把数据向右移动，后面 A 的值会被推走，前面补 `0`，这样直接就得到了 B 的值。

```
使用 shr(4, 67)

0100 0011 → 0000 0100
```

得到 `0000 0100` 也就是 `4`，B 的值也得到了！

**总结：**

至此就掌握了 EVM 数据压缩的核心：

- **打包**：使用 `shl` 移位，用 `or` 打包
- **解包**：使用 `and` 提取低位，使用 `shr` 来提取高位

## 四、XOR 运算：对合性与加密

我们再补充一个东西，叫做 `XOR`，符号是 `^`。

### 4.1 XOR 运算规则

这个很有趣，它是：如果两个位不同，则为 `1`，相同则为 `0`。

### 4.2 归零律

在区块链和密码学中，XOR 有一个重要的特性：**归零律**。

任何数字和它自己做 XOR，结果一定是 `0`。

### 4.3 对合性示例

假设我们有一个数字 `S = 9`（`1001`），有一个密钥 `K = 7`（`0111`）。

**加密：**

```
计算 S XOR K（9 ^ 7）

  1 0 0 1
^ 0 1 1 1
---------
  1 1 1 0
```

值是 `1110`，十进制则为 `14`，这就是我们的密文 `C`。


**解密：**

现在使用我们的密文 C 再做一次 XOR 和 K 能得到什么？

```
C XOR K（14 ^ 7）

  1 1 1 0
^ 0 1 1 1
---------
  1 0 0 1
```

还原了 `S`！这就是 XOR 的**对合性**：`A ^ B ^ B = A`

### 4.4 应用场景

在智能合约中，这种特性通常用于：

1. 简单的加密
2. 生成随机种子
3. 更重要的是它可以不使用临时变量来交换两个变量的值，省下一个栈空间

## 五、有符号整数与 SAR 运算

### 5.1 负数的问题

我们做 `shr` 的时候，是把所有数字当正数处理的，它的规则是左边空出来的位置一律补 `0`。

但是 Solidity 和 EVM 的底层，负数是通过**补码（Two's Complement）**来实现的，简单来说就是负数的二进制最高一位一定是 `1`。

如果我们使用 `shr` 对负数做运算，那么就会出 bug，最高的一位就会变成 `0`。

### 5.2 SAR 运算（Signed Arithmetic Shift Right）

所以我们有一个专门处理负数的运算：`sar`（Signed Arithmetic Shift Right）。

`sar` 是专门为有符号整数设计的。

`sar` 的时候，会在第一位设置一个数：

- 如果原来是 `0`，那么就会写 `0`
- 如果原来是 `1`，就会写 `1`

这样就能保证正数除完还是正数，负数除完还是负数。

### 5.3 补码原理

我们通过一个例子来看看它的方式。

假设只有 8 位，这样便于展示。

我们假设有一个数字 `-4`，二进制表示是 `x = 1111 1100`。

为什么是这样？

在补码的世界里，最高的一位有特殊的权重，它表示最高一位的负数。

比如在我们的例子 `1111 1100` 中，最高的一位就表示 `-128`。

那么我们计算一下：`4 + 8 + 16 + 32 + 64 - 128 = -4`！结果没问题。

### 5.4 SHR vs SAR 对比

**使用 shr：**

```
shr(1, x) = 0111 1110
```

最高位变成 `0` 则变为正数了！这是错误的。

**使用 sar：**

```
sar(1, x) = 1111 1110
```

这时候 `sar` 会把最高位继续写上 `1`，完全对了。

`1111 1110` 按照我们刚才的算法：`2 + 4 + 8 + 16 + 32 + 64 - 128 = -2`，结果也正确。

### 5.5 特殊情况：-1

但是我们再讲一个 `-1`：`1111 1111`

如果执行 `sar(1, -1)` 结果是多少？

还是 `1111 1111`。

因为 `sar` 也是向下取整，`-1 / 2 = -0.5` 向下结果还是 `-1`。

所以保证了数学逻辑的一致性，无论正负，`sar` 用于等于除以 `2^n` 并向下取整。

## 六、int 与 uint 的区别

为什么我们要学习负数？

因为 Solidity 中有 `int` 和 `uint` 两种。

### 6.1 int8（有符号整数）

正是我们上面讲的，第 8 位是 `-128`，第一位就是 `1`，后面最多也只能表示 `-1`。

如果想表示正数，第一位一定是 `0`。

在 `int8` 中，正数最大是 `127`，想存 `128`？没招，会溢出。

**范围：`-128` 到 `127`**

### 6.2 uint8（无符号整数）

这个 `u` 代表了无符号即 Unsigned，在这个设定中，我们规定不允许有负数。

所以第一位就不代表 `-128`，代表 `+128`。

这时候 `1111 1111` 就变成了：

```
128 + 64 + 32 + 16 + 8 + 4 + 2 + 1 = 255
```

**范围：`0` 到 `255`**

明白了吧！

## 总结

本节我们学习了 EVM 中的位运算优化技巧：

1. **shl/shr**：用于快速乘除 2 的幂次方
2. **and**：用于取模和数据掩码
3. **or**：用于数据打包
4. **xor**：用于加密和变量交换
5. **sar**：用于有符号整数的右移

掌握这些技巧，可以在智能合约开发中显著节省 Gas 费用！
