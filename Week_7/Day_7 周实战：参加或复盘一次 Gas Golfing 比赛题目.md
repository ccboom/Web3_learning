# 我们今天研究一下 Gas Golfing 比赛题目

极限 Gas 优化不仅仅是省钱，更是深入了解 EVM 底层机制的绝佳方式，我们像专家一样，从字节码和 opcode 的微观角度来审视代码。

为了让这次实战既有深度又易于上手，我们从简单的例子开始深入。

## 第一关：循环与内存之战

首先我们写一个基准代码：

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract GasGolf {
    // 任务：将这个函数的 Gas 消耗降到极限
    function sum(uint256[] memory nums) external pure returns (uint256 total) {
        for (uint256 i = 0; i < nums.length; i++) {
            total += nums[i];
        }
    }
}
```

这个逻辑没有什么问题，但是在 Gas 消耗上非常奢侈。

### 1. 内存 vs Calldata

我们只要改动一个词就能省下大量 gas，你知道是哪个吗？

这里我们要回顾一下 EVM 处理数据的两种方式：

1. **复印一份：memory**
    当你使用 memory 的时候，EVM 会把用户传进来的整个数组复制一份到 memory。每次复制一个数字都需要付 Gas，数组越大，复制越贵。

2. **直接阅读：calldata**
    如果你告诉 EVM，直接去读取原始数据，他就不用花钱搬运，而是用到那个就去读哪个。省去了昂贵的复制费用，特别对于只读的大型数组。

现在我们回到代码： `function sum(uint256[] memory nums)`，你知道改哪里了吧？

把 `memory` 改为 `calldata` 是最立竿见影的省钱招数，省去了复制的步骤。

现在我们的第一行代码进化了：

```solidity
function sum(uint256[] calldata nums) external pure returns (uint256 total)
```

### 2. Unchecked 与 循环优化

让我们看看循环的代码：

```solidity
for (uint256 i = 0; i < nums.length; i++)
```

在 0.8.0 之后的版本中，编译器非常谨慎，它会自动给每一个运算加上一层 **安全锁**，来检查这个数字是不是变得太大了，是不是会溢出，每次检查都要花大量的 gas。

请你思考一下：在这个循环中，从 `i = 0` 开始增加，直到数组长度为止，会超出 `uint256` 的上限吗？

**绝对不可能**，那么大的数组会花费天价的 GAS。
所以每次都去循环检查纯属是浪费时间，就像每次回家还得查身份证一样多余。

在 solidity 0.8+ 中，我们可以使用 `unchecked` 来告诉编译器：放心，这部分我保证不超出去。能省去很多 Gas。

> **unchecked 是干啥的？**
>
> * **Solidity 0.8.0 之前**：如果里程表到了 9999999，再开 1 公里，他会直接变成 0000000，这个叫做 **溢出**。虽然数字不对了，但是车还能开，这是以前很多漏洞的来源。
> * **Solidity 0.8.0+**：为了安全，设置了一个安全锁，如果到了 999999 你还想开，他会让引擎熄火（revert），防止数组变成我们预料之外的结果。
>
> **代价呢？** 就是我们每次做加法，他都要检查一下，是不是超出去了，这需要消耗额外的 Gas。
>
> **unchecked 的作用**：你作为一个开发者，可以确定这个数值 100% 不会爆表的时候，你可以用 `unchecked` 告诉编译器，把那个安全锁拆了，我自己能处理后果，这样就省下了检查的钱。

现在循环长这样：

```solidity
for (uint256 i = 0; i < nums.length; i++) {
    total += nums[i];
}
```

如果要用 `unchecked` 包裹起来 `i++`，我们需要改变一下 for 的结构。我们要把 `i++` 挪到循环体内部，然后包裹起来。

还有一个小细节，在 Gas 优化中，我们通常使用 `++i` 而不是 `i++`，因为 `i++` 在底层逻辑中需要先保存旧值再加一，而 `++i` 则是直接加一，稍微能省一点点 gas。

代码如下：

```solidity
for (uint256 i = 0; i < nums.length; ) {
    total += nums[i];
    unchecked { ++i; }
}
```

### 3. 缓存数组长度

现在我们要看看循环上面的 `i < nums.length` 了。

这一个代码代表着我们每一次循环，EVM 都得去读取一下 `nums` 数组到底有多长，这就像在赛车比赛，每次开一小段就要问一下裁判，我跑完这圈了吗，效率很低。

虽然 `calldata` 比读取内存便宜，但是依然比读取栈要贵许多。
我们试着在循环开始之间，就把长度存在一个变量中，这样就不用每次都读取了。

所以我们在循环之前要写：

```solidity
uint256 len = nums.length;
```

这样就不用每次去寻找长度了。

### 4. 循环展开 (Loop Unrolling)

接下来我们要把循环展开，这是非常暴力的手段。

比如我们在搬砖：

* **普通循环**：每次搬一块，1000 块要搬 1000 次。
* **循环展开**：每次搬 10 块，1000 块只需要 100 次。

虽然砖总数没变，但是你走的路次数变了，大大减少了。

那我们在循环中，一次性处理两个元素，代码会有什么变化？
循环中的 `total += ...` 需要写两行，每次 `i` 增加 2。

但是这里有一个致命的陷阱。我们要小心越界的问题，比如数组长度 `len = 5`：

* 第 1 轮 (i = 0)：处理 nums[0] 和 nums[1]。✅ 没问题。
* 第 2 轮 (i = 2)：处理 nums[2] 和 nums[3]。✅ 没问题。
* 第 3 轮 (i = 4)：处理 nums[4] 和 nums[5]... ❌ **崩了！**

因为 `nums[5]` 根本不存在，所以程序会直接 revert。
为了防止这种情况的发生，我们需要保证 `i + 1 < len`。

所以代码如下：

```solidity
function sum(uint256[] calldata nums) external pure returns (uint256 total) {
    uint256 len = nums.length; 
    
    uint256 i = 0;
    // 循环展开：一次处理2个
    for (; i + 1 < len; ) {
        total += nums[i];
        total += nums[i+1];
        unchecked { i += 2; }
    }
    
    // 处理剩下的那一个（如果是奇数长度）
    if (i < len) {
        total += nums[i];
    }
}
```

通过几步的优化之后，这个函数的 gas 消耗已经大大降低！这就是专家级代码的审美。

## 第二关：存储压缩艺术

我们先回顾一下前面的内容，二进制的存储。
`uint32`，`uint256` 这些，都能存多少东西？是几字节？

比如我们拿 `uint32` 举例：
`uint32` 里的 32，说的是 32 位（bits）。
位是计算机里最小的单位，就是 0 或者 1。

在计算机的世界里，1 字节（Byte） = 8 位（bits），这是铁律。
所以计算一下：

$$32 \text{ Bits} \div 8 = 4 \text{ Bytes}$$

所以 `uint32` 占 4 字节，`uint16` 占 2 字节，`uint256` 占 32 字节。

那他能存多少数呢？
计算机只认识 0 和 1。

* 如果只有 1 位，你能存 2 个数：0, 1 ($2^1$)
* 如果有 2 位，你能存 4 个数：00, 01, 10, 11 ($2^2$)
* ...
* 如果有 32 位，你能存多少个数？
    2 的 32 次方：$$2^{32} = 4,294,967,296$$

因为我们要从 0 开始数，所以 `uint32` 能表示的最大数字是 4,294,967,295（大约 42.9 亿）。

接下来我们用一个例子理解一下。我们要设计一个合约：

* `isAdmin` (是否是管理员)
* `isActive` (账户是否激活)
* `canMint` (能否铸造)
* `canBurn` (能否销毁)
* `lastUpdated` (上次更新的时间戳)

你先写一组变量体来存储这 5 个数据：

```solidity
bool isAdmin;      // 1 字节
bool isActive;     // 1 字节
bool canMint;      // 1 字节
bool canBurn;      // 1 字节
uint32 lastUpdated; // 4 字节
```

这样很完美，把 `uint32` 变成 `uint256` 行不行？
显然是不行，如果变成 `uint256` 则占 32 字节，32 + 1 + 1 + 1 + 1 超出了一个 slot 的范围，会使用两个 slot，贵了许多。

为了看清，请看下表：

| 字节位置 (Bytes) | 变量内容 |
| :--- | :--- |
| 0 | isAdmin |
| 1 | isActive |
| 2 | canMint |
| 3 | canBurn |
| 4 - 7 | lastUpdated |
| 8 - 31 | (空闲，还可以塞更多东西!) |

**省钱效果**：只需要支付一次 SSTORE 的钱，就能同时更新这五个变量，在以太坊相当于打了五折！
