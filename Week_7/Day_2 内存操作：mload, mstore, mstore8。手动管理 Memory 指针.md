# W7D2: Yul 中的内存操作

## EVM 内存概述

首先 EVM 的内存我们已经讲过了。

想象一下,它像一个无限延长的格子状的纸带,一个格子的大小是 **1 byte**(也就是 8 位二进制,比如 `0xFF`)。

这里每一个格子都是有编号的,从 0 开始,后面 1、2、3......

而且这个纸带是**一次性的**,用完了就直接扔了,下次用的时候再拿一个新的。

## 内存操作工具

现在手里有三个工具来操作这个纸带。

### 写入工具

首先是写的工具,可以把数据写到方格中。

#### 1. `mstore(p, v)`

- `p` 指的是 **position**(位置),也就是从哪里开始放
- `v` 指的是 **value**(数值),你要放的数据

EVM 是 256 位的机器,所以它最喜欢操作的单位是 **32 字节**。

当你使用 `mstore` 的时候,你像手里拿着一个大印章,直接盖下去。因为这个印章是 32 个格子的,所以每次从 `p` 到 `p+31` 格子的数据不管有没有,全部都会被覆盖。

#### 2. `mstore8(p, v)`

这个则像我们使用的个人印章。

它只盖在 `p` 这一个格子里面,写下数值 `v` 的最后一个字节,不会影响旁边的其他格子。

### 内存覆盖示例

那如果我们现在取一个全新的纸带:

1. 我开始的时候用 `mstore(0, AAAAA..AA)` 盖了一下
2. 后面我又使用 `mstore(1, BBBB..BB)` 盖了一下,这时候会怎样?

**结果**:这时候只有 0 号格子是 A,从 1 号到 32 号格子全部被 B 给覆盖了!

这不对啊,我不知道哪里有数据啊,总不能每次都靠脑子记忆,总有记不住的时候。

## Free Memory Pointer (空闲内存指针)

这时候就引出了新的东西:**Free Memory Pointer (空闲内存指针)**

我们不能每次都找哪个位置开始空着,太麻烦了。我们直接取纸上的一个格子,规定这个格子记录从哪一个格子开始是空白的,可以书写。

- 我们设定它的位置是 **`0x40`**(也就是十进制的 64 的位置)
- 初始的值通常是 **`0x80`**(也就是十进制的 128),表示前面的 128 个格子都被占用了

### 内存布局

那前面 64 个字节是干嘛的?怎么不记录在 0 的位置?

#### `0x00-0x3F`: Hash 草稿纸区域

这个区域是 hash 的草稿纸区域。

我们每次使用 `keccak256` 的时候,需要有地方计算,总不能每次都申请新内存,那样非常贵。

所以我们一开始的时候就直接规定了,空出前面的 64 个格子,当作草稿纸来用,这样就节省了每次申请内存的费用。

#### `0x40-0x5F`: 空闲内存指针区域

- `0x40`: 存储空闲内存指针
- `0x41-0x5F`: 空的,通常也没人用

#### `0x60-0x7F`: Zero Slot

永远保持 0,作为初始值。

## 标准内存操作流程

所以标准的内存操作流程是:

### 1. 查找位置
先去 `0x40` 看看从哪里开始是空闲的

### 2. 存数据
使用 `mstore` 或者 `mstore8` 存储数据

### 3. 更新位置
把 `0x40` 更新为我们写入数据之后的新位置,方便下一个人来读取

**示例**:假如刚刚我们占用了 32 字节(十六进制是 `0x20`),原本格子里记录的位置是 `0x80`,那我们现在应该把位置改为多少?

**答案**:应该是 `0x20 + 0x80 = 0xA0`

现在 `0xA0` 之后才是空白的格子。

## 读取工具

### `mload(p)`

`mstore` 是盖章,`mload` 是把数据从 `p` 的位置拿出来看看。

但是使用 `mload`,它会把从 `p` 开始的后面 **32 个格子**的数据一次全给你拿出来。

它会把这些数据复制到你的栈里面供你使用,**不会改变**任何本身纸带上格子内的数据。

我们读取 `0x40` 的操作就是:`mload(0x40)`

## 更新空闲指针

好了,我们算出来新的位置是 `0xA0`,所以把 `0xA0` 使用 `mstore` 存入 `0x40` 的位置上:

```solidity
mstore(0x40, 0xA0)
```

## 完整代码示例

我们使用代码来解释一下内存的操作流程:

```solidity
assembly {
  // 第一步:找位置,从 0x40 中读取空的位置
  let freeptr := mload(0x40)
  
  // 第二步:写数据,把要写的数据从空的位置开始写入进去
  mstore(freeptr, 0xaaaa...)
  
  // 第三步:更新位置,把 0x40 的内容更新为最新的空位置
  // 要记得使用 add() 函数,因为 Yul 没有 + 这个操作符号
  mstore(0x40, add(freeptr, 0x20))
}
```

---

**总结**:
- EVM 内存是一个临时的字节数组
- `mstore(p, v)` 写入 32 字节,`mstore8(p, v)` 写入 1 字节
- `mload(p)` 读取 32 字节
- 使用 Free Memory Pointer (`0x40`) 来追踪空闲内存位置
- 标准流程:读取指针 → 写入数据 → 更新指针
