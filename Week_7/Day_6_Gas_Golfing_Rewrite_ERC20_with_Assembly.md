# Day 6: Gas Golfing - Rewriting ERC20 Core Functions with Assembly to Save Gas

Today, applying what we've learned this week, we will optimize the ERC20 contract we wrote previously.

## Why use Assembly (Yul)?

In the EVM, although Solidity is easy to write, the bytecode generated by the compiler is not always the streamlined most.
Using Yul, we can directly **bypass some of Solidity's safety checks** (such as overflow checks, etc.) and **operate directly on the stack, memory, and storage**, thereby significantly reducing Gas consumption. This technique, known as "Gas Golfing," is very common in DeFi protocols that pursue extreme efficiency.

---

## 1. Reviewing our ERC-20 Contract

Before we start optimizing, let's look at the standard Solidity implementation version:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

contract MyToken {
    // 1. Variables: Token name and symbol
    string public name = "My First Token";
    string public symbol = "MFT";
    uint8 public decimals = 18;
    uint256 public totalSupply;

    // 2. Ledger: Balances and Allowances
    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    // 3. Events: The Loudspeaker
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    // 4. Mint Function: Printing money out of thin air (Allowed for everyone for testing)
    function mint(uint256 amount) public {
        totalSupply += amount;
        balanceOf[msg.sender] += amount;
        emit Transfer(address(0), msg.sender, amount);
    }

    // 5. Transfer Function: I send to you
    function transfer(address to, uint256 amount) public returns (bool) {
        require(balanceOf[msg.sender] >= amount, "Not enough tokens");
        balanceOf[msg.sender] -= amount;
        balanceOf[to] += amount;
        emit Transfer(msg.sender, to, amount);
        return true;
    }

    // 6. Approve Function: I allow you to use my money
    function approve(address spender, uint256 amount) public returns (bool) {
        allowance[msg.sender][spender] = amount;
        emit Approval(msg.sender, spender, amount);
        return true;
    }

    // 7. TransferFrom: You use my money to send to others (DeFi Core)
    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
        require(allowance[sender][msg.sender] >= amount, "Allowance exceeded");
        
        allowance[sender][msg.sender] -= amount; // Deduct allowance
        balanceOf[sender] -= amount;             // Deduct owner's balance
        balanceOf[recipient] += amount;          // Increase recipient's balance
        
        emit Transfer(sender, recipient, amount);
        return true;
    }
}
```

---

## 2. Core Challenge: Manual Storage Layout

Before rewriting the ERC20 core functions, the first and most critical challenge we face is: **Manual Storage Layout**.
Solidity handles the location of variables in storage (Slots) automatically for us, but in assembly, we must calculate them ourselves.

Let's locate the data first, based on the order of defined variables:

| Variable Name | Storage Location (Slot) | Type |
| :--- | :--- | :--- |
| `name` | Slot 0 | string |
| `symbol` | Slot 1 | string |
| `decimals` | Slot 2 | uint8 |
| `totalSupply` | Slot 3 | uint256 |
| `balanceOf` | Slot 4 | mapping |
| `allowance`  | Slot 5 | mapping |

### How to Calculate the Storage Location of a Mapping?

Suppose we now want to modify `msg.sender`'s balance in `balanceOf` (Slot 4).
Do you know what formula or algorithm the EVM uses to figure out the specific storage location for this row of data?
The answer is: **Using Hash Collision mechanism to determine where data is stored**.

The calculation formula for the storage location of a Value corresponding to a Key is as follows:

$$StorageLocation = keccak256(Key + SlotIndex)$$

In our example:

- **Key**: The address we want to query, e.g., `msg.sender`.
- **SlotIndex**: The storage location of the Mapping variable itself, `balanceOf` is at slot 4.

What we need to do is concatenate these two things together and perform a Hash operation.
In Yul, we cannot directly use `+` to concatenate; we need to utilize **Memory** as a temporary storage area.

### Location Steps Breakdown

Suppose we want to calculate the location of `balanceOf[msg.sender]`, we need two `mstore` operations.
We need to write `msg.sender` (Key) and `4` (SlotIndex) into the first 32 bytes (0x00) and the subsequent 32 bytes (0x20) of memory, respectively.

That is:

```yul
mstore(0x00, caller()) // Write Key (msg.sender)
mstore(0x20, 4)        // Write Slot Index
```

Now we have two pieces of key information in our memory:

- `0x00 - 0x20`: msg.sender (padded with zeros)
- `0x20 - 0x40`: 0x00...04

With the data laid out, we need to feed this entire chunk of data into the hash function to calculate the final storage address.
In Yul, the instruction to calculate the hash is `keccak256(offset, size)`.

- `offset`: From which position in memory to start reading data
- `size`: The total length of data to read in bytes

The code looks like this:

```yul
keccak256(0x00, 64)
```

Reading `64` bytes of data starting from `0x00` means **32 bytes Key + 32 bytes Slot position**.

We usually assign it to a variable, like this:

```yul
let location := keccak256(0x00, 64)
```

Now we have `location` in hand, which is the actual address where `balanceOf[msg.sender]` resides in Ethereum's vast storage space.

### Reading and Writing

Since we have found the location, we need to retrieve the data from this location.
In Yul, the instruction to read data from Storage is `sload(p)`, where p is the storage position.

Reading code:

```yul
let currentBalance := sload(location)
```

Using this code, we can fetch the value from the warehouse and place it at the top of the stack.

Suppose we are now rewriting the `mint()` function, and our goal is to increase this balance by `amount`.
In Yul, addition uses `add(x, y)`.

```yul
let newBalance := add(currentBalance, amount)
```

We are just one step away: writing to storage.
We use `sstore(p, v)` to write it to storage:

```yul
sstore(location, newBalance)
```

---

## 3. Hands-on: Rewriting the mint() Function

Let's review the logic of the `mint` function:

```solidity
function mint(uint256 amount) public {
    totalSupply += amount;           // <--- Do this next
    balanceOf[msg.sender] += amount; // The process explained above âœ…
    emit Transfer(address(0), msg.sender, amount);
}
```

### 3.1 Handling totalSupply

Next, we need to handle `totalSupply += amount;`.
Compared to handling mappings, handling ordinary variables is much simpler because it doesn't require calculating a hash calculation; the location is fixed.
Recall that `totalSupply` is at **Slot 3**.

So our steps should be: First read the value in Slot 3, then add the amount, and finally put it back into Slot 3 to update.
Done in one line of code:

```yul
sstore(3, add(sload(3), amount))
```

### 3.2 Handling Events

Finally, we need to emit events.
In the `mint` function, the event emission is defined like this:
`event Transfer(address indexed from, address indexed to, uint256 value);`

In Yul, there is no `emit` keyword at all. We have to use the `logN` series of instructions, such as `log1`, `log2`, `log3`, `log4`.
The number `N` after `log` represents how many **Topics** this event has.

So how many Topics does ours have?

1. **Event Hash Signature**: Itself counts as the first Topic.
2. **Indexed Parameters**: Each parameter marked as `indexed` also counts as a Topic.

So we can clarify:

- **Topic 1**: Hash of the `Transfer` event signature (Must have)
- **Topic 2**: `from` address (indexed)
- **Topic 3**: `to` address (indexed)
- **Data Part**: `value` (because it is not indexed)

So we need to use `log3`.
Instruction format: `log3(offset, size, topic1, topic2, topic3)`.

Next, we need to prepare two parts of content:

1. **Memory Data (Data)**: You need to write non-indexed parameters into memory first; here it is `amount`.
2. **Topics**: Prepare values for the three Topics.

Code construction:

```yul
// 1. Prepare Data
mstore(0x00, amount)

// 2. Prepare Topics and Emit
// topic1: Transfer event signature
// topic2: from (0x00...00)
// topic3: to (msg.sender)
let transferSig := 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef
log3(0x00, 32, transferSig, 0, caller())
```

> **Why is the source 0?**
> Because we are doing the `mint()` function, which is a function that prints money out of thin air. The tokens are not transferred from someone's hand but are generated from the void.
> On the blockchain, we use the **Zero Address** to represent the void or the system.

### 3.3 Complete Code Display

Stitch them together and see what the `mint` function looks like after being rewritten with assembly:

```solidity
function mint(uint256 amount) public {
    assembly {
        // ---------------------------------------------------
        // 1. Update balanceOf[msg.sender] += amount
        // ---------------------------------------------------
        mstore(0x00, caller())   // memory[0x00] = msg.sender
        mstore(0x20, 4)          // memory[0x20] = 4 (balanceOf Slot ID)
        
        let slotBalance := keccak256(0x00, 64) // Calculate Mapping Hash Slot
        
        // Load -> Add -> Store
        let currentBal := sload(slotBalance)
        sstore(slotBalance, add(currentBal, amount))

        // ---------------------------------------------------
        // 2. Update totalSupply += amount
        // ---------------------------------------------------
        // totalSupply is fixed at Slot 3
        let currentSupply := sload(3)
        sstore(3, add(currentSupply, amount))

        // ---------------------------------------------------
        // 3. Emit Transfer Event
        // ---------------------------------------------------
        // Need to calculate the hash of the event signature (Transfer(address,address,uint256))
        // keccak256("Transfer(address,address,uint256)")
        // = 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef
        let transferSig := 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef
        
        mstore(0x00, amount) // Write amount (Data part) to memory ready for emission
        
        // log3(offset, size, topic1, topic2, topic3)
        log3(0x00, 32, transferSig, 0, caller())
    }
}
```

---

## 4. Summary and Trade-offs

Rewriting with assembly not only saves Solidity's default overflow checks but also skips reading and writing many intermediate variables.
But, looking at the assembly code we just wrote, what do you think is the biggest price we paid compared to the original Solidity code?

Although we save users Gas at runtime, to implement these manual logics, the bytecode size of the code often swells, leading to increased deployment costs. This is a typical example of **"Space for Time"** (Space fees at deployment vs. Gas fees at runtime).

### Comparative Analysis

| Dimension | Standard Solidity | Yul Assembly Optimization |
| :--- | :--- | :--- |
| **Readability** | High, logic is clear at a glance | Low, like reading hieroglyphics |
| **Security** | Compiler helps you check (overflow, division by zero, etc.) | All handwritten, missing one `if` could lead to funds theft |
| **Audit Difficulty** | Auditors only need to check logic loopholes | Auditors need to check stack operations line by line, easy to miss things |
| **Maintainability** | Easy to modify and upgrade | Changing one line of code might require recalculating all stack positions |

**Conclusion**: We typically only use this extreme optimization for core functions that are **called extremely frequently** and have **relatively simple logic** (such as `transfer`, `approve`).

---

## 5. Practical Drill (Homework)

The remaining functions are left for you to practice! Try rewriting the `burn` (destroy) or `transfer` function using assembly.

**Tips:**

1. `transfer` needs to check if the balance is sufficient (`sub` instruction will underflow to a huge number for unsigned integers if the result is negative, and Yul will not report an error, so you need to manually check `gt` or `lt`).
2. Don't forget to update both people's balances (sender decreases, receiver increases).
