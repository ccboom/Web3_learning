# Day 4: 调用操作：在汇编中进行 call 和 delegatecall

## 概述

我们今天着重讲一下汇编级调用。这个非常容易把人搞晕。

在 Yul 中，`call` 和 `delegatecall` 的区别是：**在哪里执行，用谁的资源？**

这个我们在前些时候讲过，重新复习一下。

## 核心概念回顾

想象你在一家工厂当总经理：

### 1. call：普通调用

这时候有个客户要做一个零件，发给你（合约 A）一个订单，但是你忙不过来。

这时候你给隔壁厂（合约 B）打电话说：这是钱，这是单子，你帮我做一下。

这时候材料用的是隔壁厂的材料，地方用的也是隔壁厂的地方，做完了隔壁厂会把结果告诉你说做完了。

**相当于在 B 的区域做事，上下文环境已经改变了。**

### 2. delegatecall：委托调用

客户要做一个零件，发给你一个订单，但是你不会做。

所以你请隔壁厂的工人（合约 B 中的逻辑）请到了你们厂。

用你自己厂的材料和地方，做出来了零件。

虽然工人是隔壁的，但是消耗的却是你自己的材料。

**相当于在本厂做事，上下文环境还在自己的厂子里没有改变。**

## 参数详解

复习完毕，我们来看看今天的内容。首先来看看他们的参数表：

### call 参数

```solidity
call(g, a, v, in, insize, out, outsize)
```

- `g`：Gas - 准备使用多少 gas
- `a`：Address - 目标地址
- `v`：Value - 转过去多少 ETH
- `in`：输入数据在内存的起始位置
- `insize`：输入数据的大小
- `out`：输出数据存在哪里
- `outsize`：输出数据的大小

### delegatecall 参数

```solidity
delegatecall(g, a, in, insize, out, outsize)
```

参数几乎一样，只不过少了 `v`。

### 为什么没有 Value 在参数里面了？

想想我们刚刚复习的地方：

- 使用 `call` 的话，我们需要给隔壁工钱（gas fee），然后再给人家加工的材料钱，因为订单里的钱在你这里，所以需要你转钱给隔壁厂（带着 value）。
- 使用 `delegatecall`，我们请隔壁的工人来我们自己的厂子里，只需要给他工钱就行了（gas），订单里的钱还在你这里，隔壁厂的工人可以花订单里的钱直接采购材料，所以不需要带着 value 了。

## 上下文差异

在 `call` 中，`msg.sender` 会变成合约 A，但是在 `delegatecall` 中，`msg.sender` 会变成发送者本身。

## 存储槽冲突风险

这对于存储来说也有风险，其实就是我们 W5D1 讲的存储槽冲突。

**EVM 只认 slot，不认变量名。**

### 示例场景

如果合约 A 存在两个变量：
- `slot 0`：owner
- `slot 1`：balance

合约 B 存在两个变量：
- `slot 0`：balance
- `slot 1`：hash

那现在我们要请合约 B 也就是隔壁工人操作我们的变量，这时候告诉他我要操作 balance：因为合约 B 不知道你家的变量名，它只知道自己的变量放在 `slot 0`。

所以它把计算好的值放入 `slot 0`，把我们的 `owner` 变量覆盖了！**永久的丢失了合约控制权**。

这就是**存储冲突**，记起来了吗？

### 防止存储冲突的规则

为了防止合约 B 覆盖掉合约 A 的 `owner` 变量，我们需要给这两个合约立个规矩：

如果 A 和 B 必须共用一个书架，那么我们在编写变量顺序的时候，想给 B 增加一个变量，**必须写在变量列表的最后面**以保证 A 的变量的完整性。

## RAW 调用

接下来我们讲讲 RAW 调用。

### 什么是 RAW？

RAW 在这里的意思就是：**没有任何修饰，没有任何预处理，直接操作二进制数据**。

我们做个类比：

比如我们在发快递：

- **调用 Solidity 的时候**：拿着你要发的东西去快递站，快递员（编译器）会帮你包装，贴条，贴单子，你不用关心东西在箱子里面怎么样，你只要给快递员就可以搞定。

- **Raw Call**：你自己打包，你得拿纸箱（分配内存），把东西放进去（写入数值），你必须自己量尺寸（计算 data size）然后再把这个封好的箱子放到车上，这就是 RAW，你必须手动处理每一个步骤（字节）。

### 代码层面的对比

让我们从代码的层面看看有什么不同：

#### A. Solidity 调用

```solidity
token.transfer(0x123...9, 100)
```

编译器在后台默默做 auto packing：
1. 查表找到 `transfer` 的函数 ID `0xa9059cbb`
2. 把 `0x123...9` 格式化为 32 字节
3. 把 `100` 格式化为 32 字节
4. 打包发送

#### B. Raw Call

没有编译器帮你打包，你必须自己手动处理这些字节：

```solidity
assembly {
    // 手动写入函数 ID 到开头
    mstore(0x00, shl(224, 0xa9059cbb))
    // 手动写入第一个参数（地址）
    mstore(0x04, 0x123...9)
    // 手动写入第二个参数（金额）
    mstore(0x24, 100)
    // 告诉 EVM：从 0x00 开始，取 68 个字节发出去
    // 这就是 Raw Call，你控制了每一个字节！
    let result := call(gas(), address, 0, 0x00, 68, 0, 0)
}
```

## 实际应用：极致省 Gas 的骚操作

我们理解了原理，现在来看看实际的应用。为了极致的省钱，我们会有一些骚操作：

```solidity
assembly {
    // 1. 准备输入数据
    // 把内存指针 0x40 处的数据（args）拿出来
    let ptr := mload(0x40)

    // 2. 执行 delegatecall
    // 参数含义：gas, 目标地址, 输入数据起点, 输入长度, 输出起点, 输出长度
    let result := delegatecall(gas(), _impl, ptr, calldatasize(), 0, 0)

    // 3. 处理结果 (这是个大坑！)
    // ...
}
```

### 为什么输出起点和输出长度全部都是 0？

这里有一个反直觉的地方，为什么输出起点和输出长度全部都是 0？？

你请隔壁工人做零件，做完零件后告诉他没地方放（输出空间是 0），那他会把零件直接扔到垃圾堆吗？

显然是不会，他会放在一个纸箱子里（**Returndata Buffer**）。

### Returndata Buffer 机制

在 EVM 中有一个非常特殊的临时存储区域：`returndata`。

**不管你在 call 指令有没有设置输出空间，EVM 都会自动把返回结果先放在这里。**

这个纸箱子是在**内存（Memory）之外的**，是独立的。

因为作为代理合约，压根不知道零件会占多大的地方：
- 如果做的是 5cm 的零件，那只要一个小盒子
- 做一个 5m 的零件，那得拿一个大木箱子

如果在调用之前就瞎猜分配空间，要么就浪费了空间，要么就放不下。

### 正确的流程

1. **盲调**：先调用，给 `0, 0` 的空间，让工人做好之后放入临时纸箱
2. **询问大小**：完工之后你问 EVM，箱子里的东西有多大？指令：`returndatasize()`
3. **分配内存**：根据刚刚的大小，划分一块刚够用的内存出来
4. **搬运**：把东西从临时纸箱搬到内存中去。指令：`returndatacopy(内存起始位置, 保温箱起始位置, 数据长度)`

## 终极代码示例

写一个终极代码来展示一下吧：

```solidity
assembly {
    // 把输入数据（calldata）复制到内存，准备给工人
    // 这里忽略了 calldatacopy 的细节，假设已经准备好了
    let ptr := mload(0x40)
    calldatacopy(ptr, 0, calldatasize())
    
    // 0, 0：先做，做完了之后放入临时纸箱中
    let result := delegatecall(gas(), _impl, ptr, calldatasize(), 0, 0)
    
    // 询问纸箱中数据大小
    let size := returndatasize()
    
    // 把数据从纸箱搬到内存中来
    // 把纸箱中从 0 开始的 size 长度数据，抄到内存 ptr 位置
    returndatacopy(ptr, 0, size)
    
    // 根据做的成功不成功，决定是不是上报
    switch result
    case 0 {
        revert(ptr, size)
    }
    default {
        return(ptr, size)
    }
}
```

搞定了！

## 总结

- `call` 和 `delegatecall` 的核心区别在于执行上下文
- `delegatecall` 不需要 value 参数，因为在调用者的上下文中执行
- 存储槽冲突是使用 `delegatecall` 时需要特别注意的风险
- RAW 调用提供了最大的灵活性和 gas 优化空间
- Returndata Buffer 机制允许动态处理返回数据，避免内存浪费