# secp256k1 椭圆曲线详解

深入研究比特币和许多区块链系统的核心：secp256k1 曲线。

## 学习路线

1. 曲线方程
2. 理解生成点 G

---

## 第一部分：曲线方程

### 基础方程

secp256k1 的名字听起来好像非常复杂难以理解，其实核心方程非常简单，它是维尔特拉斯方程的一个特例。

**维尔特拉斯方程：**

$$y^2 = x^3 + ax + b$$

**secp256k1 方程：**

$$y^2 = x^3 + 7$$

也就是说在方程中把 $a = 0$ ， $b = 7$ 即可。

![椭圆曲线示意图](https://github.com/user-attachments/assets/2ac1a54e-5f0c-4cc4-89cf-25e961a48066)

### 有限域的概念

在密码学中，我们不可以使用连续的实数，而是必须在一个有限域上进行操作。

**什么是有限域？**
- 域指的是一个可以自由进行加减乘除运算的数字合集
- 实数（所有小数、分数）就是无限域
- 有限域就是说这个集合的数字是有限的

我们在 $(0, 1, 2, 3, ..., P-1)$ 这个有限域上进行操作。

### 有限域中的曲线变化

如果我们将这个方程限制在有限域中，也就是对一个巨大的质数 $P$ 取模（取余数），那么平滑的曲线在几何形状上会发生什么变化？

**答案是：将会变成一团杂乱的散点。**

![有限域中的散点图](https://github.com/user-attachments/assets/5f3b2ab3-708b-4e1b-ba48-8aa2544fd11b)

### 为什么不是线了？

这就回到我们刚刚说的有限域上面：

1. **没有中间地带**：普通曲线两个整数之间会有小数，但是我们现在使用的有限域中只有整数，所以线是断的
2. **瞬间移动**：每当曲线跑出边界（大于 $P$ 的时候），就会被取模运算抓回底部，这导致点的位置跳来跳去没有规律可言

### 数学结构的完美性

虽然我们眼睛看不到它是曲线了，但是我们依然用它做加密运算，就是把两个点加在一起。你觉得我们现在还能用原本的数学公式吗？比如计算斜率：

$$slope = \frac{y_2 - y_1}{x_2 - x_1}$$

**答案当然是可以的。** 虽然在图像上看是乱七八糟，但是我们在数学层面上，代数结构依旧是完美的。

---

## 椭圆曲线上的运算

为了理解 BTC 公钥的生成（ $K_{\text{公钥}} = k_{\text{私钥}} \times G$ ），我们需要掌握曲线上的两个移动方式：加法（ $P+Q$ ）和倍点（ $P+P$ ）。

### 几何加法法则

在椭圆曲线上，加法不是简单的坐标相加： $(x+x, y+y)$ ，而是一个几何的游戏。

![椭圆曲线加法示意图](https://github.com/user-attachments/assets/c3e8f7bc-aa35-493b-993e-2a7f46038623)

**加法步骤：**

1. **连线**：想算 $P+Q$ ，那么就要画一条线穿过两个点
2. **相交**：这两个点画的直线会在第三个点相交（点 $-R$ ）
3. **翻转**：把这个交点沿着 X 轴对称反转，得到 $R$ 就是结果

这就是公式 $P + Q = R$ 的由来。

### 点倍积（Point Doubling）

接下来是生成公钥最关键的一步。想象一个特殊场景：如果我们想计算 $P+P$ ，那这时候穿过两个点的线是什么？

想象上面的图， $Q$ 沿着曲线离 $P$ 越来越近，直到和 $P$ 点重合，这时候穿过他们的直线就变成了：**切线**。

这不仅仅是一个几何概念，这个是 BTC 公钥生成中最核心的加速器。这种操作叫 **点倍积（Point Doubling）**。

计算 $P + P$ 的规则，就是把普通法里的连线变成了切线。神奇的椭圆曲线性质保证了除非 $P$ 是某些特殊的点，否则这条切线一定会延申出去并在另一个地方再次穿过曲线，我们称之为 $-R$ ，翻转之后为 $R$ 也就是 $2P$ ，如下图：

![点倍积示意图](https://github.com/user-attachments/assets/973e3d43-72a7-4557-b1a6-b4c7455f245d)

### 为什么在代数上很特殊？

我们知道斜率公式是 $m = \frac{y_2 - y_1}{x_2 - x_1}$ 。

- **对于 $P + Q$ **：因为是两个点，坐标不一样，所以分母不为0可以直接算。
- **但是对于 $P+P$ **：两个点重合了，如果使用上面的公式就变成了 $m = \frac{0}{0}$

这咋办？现在就要使用导数了，数学家通过求导算出曲线在某一瞬间的变化率。

对于 secp256k1 曲线（ $y^2 = x^3 + 7$ ），在 $P(x, y)$ 点的切线斜率公式是：

$$m = \frac{3x^2}{2y}$$

**注：** 在有限域里计算时，除以 $2y$ 要变成乘以 $2y$ 的"模逆元"。

无需记住这个公式，只要理解了 $P + P$ 的时候，计算机使用了不同于 $P + Q$ 的代数公式。

### 为什么我们要花这么大力气讲点倍积？

我们的私钥 $k$ 是一个256位数字，如果我们用公钥 $K = k \times G$ ， $G+G+G+G+...$ $k$ 次，那超级计算机也算不完。

但是现在有了点倍积（ $2P$ ），那么就可以开挂了。

**如果 $k$ 现在设为100：**

我们可以把100分为 $64+32+4$ ，所以 $100G = 64G + 32G + 4G$

- $G + G = \mathbf{2G}$ （用一次点倍积）
- $2G + 2G = \mathbf{4G}$ （再用一次点倍积）
- $4G + 4G = 8G$
- ...
- $32G + 32G = \mathbf{64G}$

我们只要6次点倍积就能得到64G，然后把我们前面得到的32G和4G加起来就行了，非常简单。

这一步让我们在极短时间内跨越了巨大的空间算出公钥，同时又无法反向推算跳了多少步，非常nice。

---

## 第二部分：生成点 G

### 生成点的定义

在 secp256k1 中， $G$ 其实就是一个大家约定好的、固定的点。

中本聪没有发明这个点，而是使用了 SECG 标准推荐的这个点。它在曲线坐标 $(x, y)$ 是两个巨大的数字（16 进制表示）：

$$G_x = \texttt{79BE667E F9DCBBAC 55A06295 CE870B07 029BFCDB 2DCE28D9 59F2815B 16F81798}$$

$$G_y = \texttt{483ADA77 26A3C465 5DA4FBFC 0E1108A8 FD17B448 A6855419 9C47D08F FB10D4B8}$$

### 公钥的生成

**公钥是怎么算出来的？**

私钥 $k$ 其实是随机选出来的一个数字，公钥 $K$ 是算出来的。

**公式为：**

$$K = k \times G$$

也就是：**公钥 = 私钥 × 生成点**

这意味着我们在曲线上从 $G$ 点出发，执行了 $k$ 次加法：

$$G + G + G + \cdots + G \quad \text{(一共加 } k \text{ 次)}$$

---

## 为什么很安全？

这是整个加密学中最精彩的部分。

### 正向计算：非常容易

你有私钥 $k$ 想算公钥，虽然 $k$ 很大（256 位整数），但是计算机不用呆呆的一个一个加。它用我们刚刚说的切线技巧，可以指数级加速计算（比如 $2G$ 、 $4G$ 、 $8G$ ...），基本在毫秒级别就完成了。

### 反向计算：基本没戏

涉及到了我们之前说的有限域散点图。如果我只给你起点 $G$ 和终点 $K$ （公钥），问你加了多少次？

由于在这个有限域里面，点跳来跳去，没有简单的代数规律可言。你没法使用 $K / G$ 这种除法。唯一的办法就是一个一个试：

- 是 1 次吗？不是。
- 是 2 次吗？不是。
- ...

### 为什么乘法可以用，除法用不了？

好像很反直觉对不对？因为 $K$ 和 $G$ 根本不是数字，他们是二维坐标点。

实际上在试图计算 $k = K \div G$ 的时候，在做这个运算：

$$k = \frac{(x_K, y_K)}{(x_G, y_G)}$$

在数学上根本不存在一个点除以另一个点的运算定义。

你可以把两个点相加，可以把一个点乘以一个整数，但从来没学过把两个点相除得到一个整数。这好比问"香蕉除以苹果是多少"，这在数学上是没有意义的。

### 安全性保证

既然 $k$ 是一个 256 位的数字，那么目前为止破解的概率基本为 0。这就是**椭圆曲线离散对数问题（ECDLP）**，也是比特币不可破解的基石。

---

## 总结

### 今天核心的学习

1. **曲线方程**： $y^2 = x^3 + 7$ （在有限域下变成了散点）

2. **运算规则**：
   - 不同点相加 $P+Q$ ：连线 → 找交点 → 翻转
   - 相同点相加 $P+P$ ：切线 → 找交点 → 翻转

3. **生成点 G**：公钥生成的唯一起跑点
