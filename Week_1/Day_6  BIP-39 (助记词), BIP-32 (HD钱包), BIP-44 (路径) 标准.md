# BIP 标准详解：助记词、HD 钱包与路径规范

本周的学习即将结束，今天开始学习 BIP-39 (助记词)、BIP-32 (HD钱包)、BIP-44 (路径) 标准，目标理解层级推导。

## BIP 的由来

**BIP** 其实是 **Bitcoin Improvement Proposal** 的缩写。

比特币是开源的，任何人都能提建议，当你写了一个技术标准并且被社区采纳，那么管理员就会给他分配一个编号，编号没什么严格的顺序，只是一个 ID 代号。

我们先把这三个标准看作一个完整的密钥管理流水线：

1. **BIP-39（原料）**：将难以记忆的随机数转化为人类可读的助记词，并生成原始种子
2. **BIP-32（核心）**：定义如何利用这个种子，结合 HMAC-SHA512 和 ECC，像树一样繁衍子密钥
3. **BIP-44（规范）**：既然能生成无限密钥，BIP-44 定义了这颗树的具体结构，哪根代表了 ETH，哪根代表了 BTC

我们顺着学习，先从 BIP-39 开始。

---

## 第一部分：BIP-39

BIP-39 的目标非常明确，它将计算机喜欢的随机数（熵），转换为人类喜欢的单词（助记词），最后再变回计算机需要的种子（seed）。

我们把他当成流水线：

**随机数 (Entropy) → 助记词 (Mnemonic) → 种子 (Seed)**

### 随机数 → 助记词

BIP-39 通常使用 2048 个单词的固定词库（wordlist），如果我们有 2048 个单词，那么每个单词能代表多少 bits 的信息量？

我们来推理一下：

- 如果只有两个单词：比如 so、last，我们只需要一个 bit 就可以区分：so = 0，last = 1
- 但是我们要是有四个单词，我们则需要 2 个 bit：so = 00，last = 01，go = 10，now = 11
- 假设有 8 个单词，我们就需要 3 bit

规律就是 $2^n = N$ ，n 为 bit 数量，N 为单词数量。

所以 2048 个单词用 **11 个 bits** 就能区分，因为 $2^{11} = 2048$ 。

这就像我们把一大串的 0 和 1 切成每 11 个一组，然后每组可以推出一个单词。

### 12 个单词的构成

现在，BIP-39 最常用的是 12 个单词的助记词，那么 12 个单词使用的则是 132 bits 的长度。

我们回忆一下，计算机生成的是 128 长度的随机数（熵），但是我们这需要 132 长度，怎么办呢？多出来了 4 位。

其实多出来的这 4 位非常关键，它的作用是防止在抄写和输入的时候写错，在密码学中，我们把他称之为**校验和（Checksum）**。

我们使用学过的 SHA-256 来保证：

1. **计算**：计算 128 位随机数的 SHA-256 hash 值
2. **截取**：取前面 4 bits 作为校验和
3. **拼接**：把这 4 bits 拼接到 128 后面

现在数据就变成了：128 位随机数 + 4 位校验和 = 132 bits

所以根据以上的推导，第 12 个单词是随机数和检验和的混合而成。结构如下：

```
总长度: 132 bits
(包含 128位 熵 + 4位 校验和)

<------------------------ 128 bits 初始随机数 ---------------------------> <--- 4b --->
+-----------+-----------+-----+-----------+------------------------------+------------+
|  11 bits  |  11 bits  | ... |  11 bits  |            7 bits            |   4 bits   |
+-----------+-----------+-----+-----------+------------------------------+------------+
|   单词 1  |   单词 2   | ... |  单词 11  |                  单词 12                  |
+-----------+-----------+-----+-----------+-------------------------------------------+
      ^           ^                 ^                    ^                      ^
    纯随机      纯随机            纯随机             随机数结尾              校验和(CS)
```

这就是为什么如果试图把最后一个单词随便换成另一个词，就会提示无效的助记词的原因。

### 助记词 → 种子

OK 我们明白了如何变成 12 个单词，现在我们要把这 12 个单词变成一个 512 位的二进制种子（seed）后面的 BIP-32 的核心，也是用这个 512 bits 的种子来生根发芽的。

这一步使用了一个叫做 **PBKDF2** 的函数，他是基于 HMAC-SHA512。

#### 什么是 HMAC-SHA512？

1. **SHA-512**：和 SHA-256 相同，只不过输出变成了 512 位
2. **HMAC**：全称是 Hash-based Message Authentication Code。普通的 hash 是 hash（内容），HMAC 是 hash（key + 内容），普通的 hash 任何人算出来都一样，但是 HMAC 需要一个密钥，如果不知道密钥则算不出来正确的 hash 值。

BIP-39 生成种子的过程中，我们使用 PBKDF2 的函数就是利用 HMAC-SHA512 反复搅拌助记词 2048 次，让他变得难以破解。

### Passphrase 的作用

在生成种子的过程中，为了增加安全性，PBKDF2 需要一个**盐（salt）**。

BIP-39 规定，这个盐由两部分组成：

1. 固定字符串 "mnemonic"
2. 用户可选的 passphrase（密码或者叫口令）

这个 passphrase 是如何起作用的？

其实不管用户有没有设置 passphrase，算法总会去拼接一个盐：

$$\text{Salt} = \text{"mnemonic"} + \text{用户设置的 Passphrase}$$

这里 2 种情况：

1. **留空**： $\text{Salt} = \text{"mnemonic"}$ ，直接去算就会得到种子 A，多数默认钱包就是如此。
2. **如果设置了 passphrase**，假设是 abc 吧， $\text{Salt} = \text{"mnemonicabc"}$ ，因为雪崩效应，输入稍微一点的改变，输出结果就大不相同，所以就会得到一个另外的种子 B。

这个有两个好处：

1. **安全性**：如果助记词丢失了，但是不知道你的 passphrase。那么恢复出来的就是留空的种子 A，而真正的种子 B 中才有资产
2. **隐蔽钱包**：可以在一个助记词下，通过设置不同的 passphrase，来生成无数个互不干扰的钱包。

OK，现在 BIP-39，你已经基本了解了。

---

## 第二部分：BIP-32

我们现在手头有了一个 512 位的种子了，我们要使用 BIP-32 来生成这个种子的根节点。

### 种子分割

这里有一个数学上分配的问题：我们学习 ECC 的时候说过，标准的私钥通常是 256 位的整数，但是我们手里的是 512 位的。

BIP-32 规定，根节点不仅需要一个私钥，还需要一个叫做**链码(Chain Code)**的东西，它也是 256 位，用来辅助生成子私钥。

所以我们把 512 位种子从中间一刀切：

- **左边 256 位** → 主私钥（Master Private Key）掌握资产核心
- **右边 256 位** → 主链码 (Master Chain Code) 用来产生子孙的基因

这两个加在一起，就产生了所谓的**扩展私钥 (Extended Private Key, xprv）**。

### 子密钥推导

现在好了，我们在根部，还有父链码和父私钥。我们要生成第一个子账户，0。

这是 BIP-32 最厉害的地方，它再次利用了 **HMAC-SHA512** 函数：

- **输入**：1. 父链码 2. 父公钥 3. 子索引号（比如 0）
- **输出**：又是一个 512 位的 hash 值，这个 512 位同样被一分为 2
  - **右边 256** → 直接成为子链码
  - **左边 256** → 这是一个中间值，他要和父私钥结合，才能算出子私钥

私钥本质是一个巨大的整数，根据我们学过的知识，把中间值和父私钥结合生成新整数，应该使用加法，这很简单：

$$\text{子私钥} = (\text{父私钥} + \text{左边256位中间值}) \bmod n$$

注：必须取模 n，如果超出曲线最大范畴，得保证它在合法的范围内。

### 公钥推导的神奇特性

这里我们还得说另一个东西，公钥推导，也是 BIP-32 的神奇特性。

在 ECC 中有一个数学规律：**同态性**

- 如果 $私钥C = 私钥A + 私钥B$
- 那么 $公钥点C = 公钥点A + 公钥点B$

这意味着我们只有父公钥和链码，虽然不知道父私钥，但是可以靠对应的偏移量点然后直接做加法：

$$\text{子公钥点} = \text{父公钥点} + (\text{左边256位} \times G)$$

这也是 HD 钱包的卖点之一！

### 实际应用场景

那么现在思考一下，这么做有什么场景可以使用？

举个例子：我们现在开了一个热度爆炸的电商网站，每天有成千上万用户下单，为了知道谁下单的，我们为每个订单都生成一个唯一的收款地址。

这时候有两个选择：

1. **方案 A**：我们把扩展私钥放在服务器上，让服务器去为用户生成
2. **方案 B**：我们把扩展私钥放入保险柜，把扩展公钥(Extended Public Key，xpub)放在服务器上

明眼人都会选后者，我们只要有父公钥，那就可以利用上面说的特性算出所有子私钥的地址。这样就可以利用 xpub 源源不断生成新的收款地址给客户。

如果有一天，黑客攻击了服务器把 xpub 拿走了，那么黑客能转走钱吗？

答案是肯定不行，他只有公钥又没私钥，所以只能看不能动。

这就是所谓的**观察钱包 (Watch-only Wallet)**。

### 硬化推导的必要性

虽然 xpub 用起来非常爽，但是在数学上有一个致命的弱点。

我们之前不是使用 子私钥 = 父私钥 + 中间值 (由父公钥和链码算出) 来推算吗？

那如果发生了：黑客偷走了 xpub，又通过某种手段拿到了一个子私钥。

现在黑客手里有 xpub，可以算出中间值，那他又拿到了子私钥，又有中间值，根据上面的公式，那不就能算出来父私钥吗？

一但父私钥被算出来，那所有分叉就全部完蛋了。

为了解决这个问题，BIP-32 发明了**硬化推导（Hardened Derivation）**，在路径里常用 `'` 或者 `h` 来表示，等会我们将路径的时候会提到。

硬化推导之所以能防黑客，是因为彻底改变了生成子密钥的材料：

- **普通推导**：原材料 = 父公钥 + 索引号
- **硬化推导**：原材料 = 父私钥 + 索引号

那么现在我们想想：黑客手里又 xpub（里面只有父公钥，没有父私钥），还偷走了一个子私钥。

现在黑客想反推父私钥：父私钥 = 子私钥 - 中间值

- 如果是普通推导，原材料是父公钥，黑客正好有！
- 如果是硬化推导，原材料是父私钥，那他根本不可能算出来的，他手里只有父公钥。就非常安全了。

这也就是为什么经常看到带 `'` 的路径比如 `44'`。这里代表有一堵防火墙。

---

## 第三部分：BIP-44

我们现在有了种子（BIP-39），有了生成树的方案（BIP-32），但是树枝不管理的话就会乱长。

**BIP-44** 就是给这个树定了一个规范，规定哪个数值干什么东西。这也就是我们上面提到过的路径。

### 标准路径结构

**标准路径示例**：`m / purpose' / coin_type' / account' / change / address_index`

**举个例子，ETH 的路径**：`m / 44' / 60' / 0' / 0 / 0`

如果想在同一个钱包同时管理 ETH 和 BTC，你觉得应该在哪里进行区分？

答案是**第二层**。

### 各层级详解

1. **第一层 Purpose**：我们写 `44` 就是告诉它说，我们按照 BIP-44 来弄的，别弄到别的上去。我们如果使用别的标准，那么就变成别的，比如 `49'`

2. **第二层 Coin Type**：
   - 比特币 (BTC) 的代号是 `0'`
   - 以太坊 (ETH) 的代号是 `60'`
   - 莱特币 (LTC) 的代号是 `2'`
   
   这就像是树枝，每一个树枝代表一个货币

3. **第三层 Account**：硬化推导，带 `'`，好比在一家银行开了好几个子账户。 `0'` 是存款账户， `1'` 是零花钱账户，即使你把零花钱账户的 xpub 给了别人，别人也无法知道你的存钱账户的情况，这就是分层的妙处

4. **第四层 Change**：通常只有两个：
   - `0` 代表收款地址，用来收钱
   - `1` 代表找零地址，这是 BTC UTXO 的特有机制，当你转账产生找零时，钱包会自动把钱转到这

5. **第五层 Address Index**：0、1、2、3......到无穷。

### 实例练习

自查一下学会了没有，我们现在使用 HD 钱包，使用第二个比特币账户里，生成第一个用于收款的地址，请推理出完整的路径。

**答案是**：`m / 44' / 0' / 1' / 0 / 0`

---

## 总结

### 1. BIP-39：原材料加工 (助记词 & 种子)

**任务**：把计算机懂的随机数，变成人懂的单词，最后变成算法懂的种子。

#### 熵变单词 (Entropy to Mnemonic)：
- **核心逻辑**：12个单词 = 132 bits 信息。
- **来源**：128 bits 纯随机数 + 4 bits 校验和 (SHA-256的前4位)。
- **原理**：132 bits 切分为 12 份，每份 11 bits。 $2^{11} = 2048$ ，正好对应2048个单词库。
- **作用**：校验和防止了抄写错误（输错一个词会报错）。

#### 单词变种子 (Mnemonic to Seed)：
- **函数**：PBKDF2 (基于 HMAC-SHA512)。
- **盐 (Salt)**："mnemonic" + Passphrase。
- **Passphrase的作用**：
  - **安全**：防物理窃取（有词无码无法盗刷）。
  - **隐蔽**：同一组助记词，不同的密码生成完全不同的钱包（种子B），互不干扰。

### 2. BIP-32：繁衍机器 (分层确定性推导)

**任务**：用一颗种子，生出无限的私钥树。

#### 根的诞生：
- 512位种子被一刀切：左边256位是主私钥，右边256位是主链码。两者合称 xprv (扩展私钥)。

#### 子钥推导：
- **公式**：子私钥 = (父私钥 + 中间值) mod n。
- **公钥特性**：利用ECC同态性，可以直接用 xpub (扩展公钥) 推导子公钥，无需私钥。
- **应用场景**：电商收款、观察钱包 (只收不付)。

#### 致命弱点与修复 (Hardened Derivation)：
- **弱点**：如果黑客有 xpub + 一个子私钥，能反推父私钥，导致全线崩盘。
- **修复**：硬化推导 (带 `'` 号)。
- **原理**：推导时切断"父公钥"的联系，强制使用"父私钥"参与运算。黑客没有父私钥，断了反推之路。

### 3. BIP-44：地址门牌号 (路径规范)

**任务**：给这棵无限生长的树定规矩，防止乱长。

#### 标准路径：
`m / purpose' / coin_type' / account' / change / address_index`

#### 层级含义：
- **Purpose (44')**：我遵循 BIP-44 标准。
- **Coin (0' 或 60')**：0'是BTC，60'是ETH。这是区分币种的地方。
- **Account (0', 1'...)**：银行里的不同子账户（存款、零花钱），使用了硬化推导，互相隔离。
- **Change (0 或 1)**：0是外部收款，1是内部找零 (UTXO特性)。
- **Index (0, 1, 2...)**：具体的第N个收款地址。
