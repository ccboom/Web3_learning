# ECDSA 数字签名详解

我们今天要学习一下数字签名：ECDSA 签名与验签流程的数学推导 (r, s, v)

**目标**: 能手算签名验证过程

---

## 第一部分：签名生成

### 椭圆曲线要素

我们刚学过的 secp256k1 曲线上面有几个要素：

1. **G**：椭圆曲线的基点
2. **n**：曲线的阶，即 $n \times G = O$ (无穷远点)
3. **d**：签名者的私钥
4. **z**：待签名的消息的 hash 值（Message Hash，截取之后转化为整数）

### 生成临时随机数

在 ECDSA 签名中最关键的一步是生成一个临时的/保密的随机数，我们称之为 **k**。

有了这个随机数 k 和昨天学到的生成点 G，我们就能计算出曲线上的一个临时点 R：

$$R = k \times G$$

现在假设 R 的坐标为 $(x_R, y_R)$

### 生成签名 (r, s)

ECDSA 签名结果由两个整数 $(r, s)$ 组成：

**r**：直接取点 R 的 x 坐标，对阶数 n 取余。

$$r = x_R \bmod n$$

（这一步是把椭圆曲线上的点转为一个纯数字）

**s**：这是最核心的一步，它把消息 hash( $z$ )，私钥( $d$ ) 和随机数( $k$ )结合在了一起：

$$s = k^{-1} (z + r \cdot d) \bmod n$$

签名就是 $(r, s)$ 这两个组合起来，当接收方拿到这两个数的时候，才进行验证。

### 理解模逆元

首先我们看看 $k^{-1}$ 这个，你会不会直接认为 $k^{-1}$ 就是简单的 1 / k？

那么你就错了，直觉上来讲是这样的，可是在椭圆曲线密码学中不同，我们不能使用小数或者分数，所有计算必须在整数范围进行，结果必须在【0，n-1】之间。

如果简单的做除法，比如 1 / 2 = 0.5，那就变成了小数，计算机无法处理这种数据。

我们使用**模逆元 (Modular Inverse)**来处理。

在模运算中， $k^{-1}$ 指的是一个整数 x，使得他和 k 相乘之后，对 n 取模的结果等于 1，公式如下：

$$k \cdot x \equiv 1 \pmod n$$

### 实例计算

我们举个例子来算一下就明白了：假设 n = 7, k = 2

我们需要找到一个整数，让 $2 \cdot x \equiv 1 \pmod 7$

算一下是多少？没错就是 **4**

所以在模 7 的世界中，乘以 4 就等于了除以 2 运算，这就是为什么我们在公式写 $k^{-1}$ ，但是在实际运算的时候我们需要先算出这个逆元整数。

### 完整的迷你 ECDSA 运算

OK，现在我们有了所有的东西，我们把他合在一起，完成一次迷你版的 ECDSA 运算。

使用公式： $s = k^{-1} (z + r \cdot d) \bmod n$

我们举一些简单的数据来运算，但是实际区块中肯定不可能是这些数据，只是为了让运算不那么复杂：

**假设：**
1. 模数 n = 7
2. 消息 hash z = 2
3. 私钥 d = 5
4. 随机点 R x 坐标 r = 2
5. 随机数逆元 $k^{-1} = 4$ （这是刚才算出来 k = 2 的时候的）

好，现在使用公式可以计算出：

s = (4 × (2 + 2 × 5)) % 7 = 6

那么在这个迷你区块链系统中，生成的数字签名 $(r, s) = (2, 6)$ ，是不是非常简单？

---

## 第二部分：验证

现在我们不是手握私钥 d 的签名者了，我们现在是一个普通的验证者，比如区块链上的矿工节点。

### 验证者拥有的信息

验证者手里有什么，这是我们必须要知道的：

1. 消息 hash $z = 2$
2. 签名 $(r, s) = (2, 6)$
3. 公钥 Q，Q 还记得怎么来的吗？由私钥 × G 也就是 $Q = d \times G$ 。我们例子中 d = 5，所以 Q = 5G
4. 曲线参数 G 和阶 n = 7

**验证的目标**：我们要用这些公开的数字算出一个点，看看它是不是等于签名中的那个 R，也就是说 x 坐标是不是等于 r。

### 验证步骤

**第一步**：算出 s 的模逆元，我们需要这个来解开签名的锁，我们把他记为 w

$$w = s^{-1} \bmod n$$

已知 s = 6, n = 7，那么自然就算出 w = 6

**第二步**：我们要算出中间参数，我们称之为 $u_1$ 和 $u_2$

公式如下：

$$u_1 = z \cdot w \bmod n$$
$$u_2 = r \cdot w \bmod n$$

由我们先前提供的条件可知 $z=2, r=2, w=6, n=7$ ，所以自然的算出：

$$u_1 = 5$$
$$u_2 = 5$$

**第三步**：已经具备了所有的条件，我们现在通过这两个数结合曲线的基点 G 和公钥 Q 来计算最终的点 P

公式为：

$$P = u_1 \cdot G + u_2 \cdot Q$$

虽然在生产环境中，涉及到非常复杂的点加法运算，但是在我们的迷你系统中，我们可以使用代数逻辑来验证一下。

还记得公钥 $Q$ 吧，把它当作 $5$ 个 $G$ 加在一起，因为私钥 d = 5，所以 Q = 5G

使用上面的公式后得到：P = 5G + 25G = 30G % 7 = 2G

完美，计算出点 P = 2G

还记得吗，往上翻一下，刚刚我们假设的 k = 2，所以点 R = 2G

计算出的点 P 和点 R 完全一致，那么说明这个签名是有效的。

### 数学原理推导

是不是一顿算之后非常困惑，为什么 $u_1$ 和 $u_2$ 能还原出 $k \cdot G$ ？

我们先总结一下公式： $P = u_1 \cdot G + u_2 \cdot Q \stackrel{?}{=} k \cdot G$ 对不对

首先回顾一下公钥 $Q$ 和私钥 $d$ 的关系是什么？把 P 变成只包含 $G$ 、 $u_1$ 、 $u_2$ 和 $d$ 的形式如下：

$$P = u_1 G + u_2 Q$$
$$P = u_1 G + u_2 (d G)$$
$$P = (u_1 + u_2 d)G$$

这下子明了

我们要证明 $(u_1 + u_2 d)$ 等于 k 就可以了

已知参数定义为：

$$u_1 = z \cdot w$$
$$u_2 = r \cdot w$$

那么提取公因数 $w$ ，公式就变成了：

$$P = \left[ (z + r \cdot d) \cdot w \right] G$$

最后，最后，中间的这一些 $(z + r \cdot d) \cdot w$ 到底代表什么？

我们回头看看 s 的原始公式：

$$s = k^{-1} (z + r \cdot d) \bmod n$$

定义阶段我们还说了 $w$ 定义是 $w = s^{-1}$ ，利用上面的代数变化，我们最终获得了：

$$k = s^{-1} (z + r \cdot d) = (z + r \cdot d) w$$

带入刚才的公式中，则变成了 $P = [\mathbf{k}] \cdot G$

那就证明了点 $P$ 恒等于签名者当初生成的随机点 $R$ ( $R = k \cdot G$ )，验证成功！

---

## 第三部分：神秘的参数 v

回看我们的标题，发现很奇怪是不是，少了一个参数 v？

我们来讲一下神秘的 $v$ (有时也叫 RecID)

在刚才的推理中，我们是已知公钥 Q 来验证签名的，但是在 BTC 和 ETH 某些时候，我们为了节省空间，在发送交易的时候不传输公钥 Q，因为它实在是太长了。

所以我们会利用数学反向恢复公钥。

这里就有一个问题，椭圆曲线是对称的，对于一个特定的坐标，曲线上会有上下两个点，这时候 v 就发挥作用了。

它就像一个简单的指示牌（通常为 27 或者 28），告诉验证者点 R 是上半区那个还是下半区那个。

有了 V，验证者就能唯一确定点 R，从而反向计算出公钥 Q，并检查 Q 地址是否有足够的余额。

### 两种验证模式

那到底是知道 Q 再计算 R，还是算出 R 再计算 Q 呢？

#### 模式一：标准 ECDSA 验签

传统的密码学流程，使用于不需要节省空间的时候

- **输入**：消息 $z$ 、签名 $(r, s)$ 、签名者的公钥 $Q$ 。
- **流程**：验证者手里已经有 $Q$ 了。利用 $Q$ 和 $(r, s)$ 算出一个点 $P$ 。判断： $P$ 的 x 坐标是否等于 $r$ ？
- **缺点**：发送交易的人必须把长长的公钥 $Q$ （64字节或33字节）也一起发给验证者，这会占用更多的区块空间，导致手续费（Gas）变高。

#### 模式二：公钥恢复模式

这是为了省钱而设计的工程优化方案。

- **输入**：消息 $z$ 、签名 $(r, s, v)$ 。
- **注意**：验证者手里没有公钥 $Q$ 。验证者只知道发送者的地址（Address，它是公钥哈希后的一小段）。
- **目标**：验证者要问："是谁签了这条消息？算出来的公钥对应的地址，是不是我有记录的那个余额充足的地址？"

这个时候计算就反过来了：

1. **利用 $r$ 和 $v$ 恢复点 $R$**：有了 $x$ ( $r$ ) 和 $y$ (由 $v$ 确定)，我们就复原出了完整的随机点 $R$ 。

2. **反向计算公钥 Q**：

   回顾最基础的等式：
   
   $$s \cdot R = z \cdot G + r \cdot Q$$
   
   (注：这其实就是 $s = k^{-1}(z + rd)$ 左右两边同乘 $k$ 再同乘 $G$ 变出来的)
   
   我们的目标是求 $Q$ 。也就是要把 $Q$ 放到等号左边，其他都扔到右边。
   
   移项： $r \cdot Q = s \cdot R - z \cdot G$
   
   两边同时除以 $r$ （也就是乘以 $r$ 的逆元 $r^{-1}$ ）：
   
   $$Q = r^{-1} (s \cdot R - z \cdot G)$$
   
   看！在这个公式里， $R$ 是已知的（第一步算出来的）， $s, z, G, r$ 都是已知的。所以，我们可以直接算出 $Q$ 。

3. **验证地址**：算出公钥 Q 之后，验证者对 Q 进行哈希运算，取出后 20 字节得到地址，然后检查这个算出来的地址，是不是这个交易的发起人？

这下能明白了吧！

---

## 总结

### ECDSA 签名与验签流程核心总结

#### 0. 核心要素准备
- **全局参数**： $G$ (基点), $n$ (曲线的阶)。
- **私密数据**： $d$ (私钥), $k$ (**随机数**，极度重要，不可泄露，不可复用)。
- **公开数据**： $Q$ (公钥, $Q=dG$ ), $z$ (消息哈希)。

#### 1. 签名生成：制造 $(r, s)$
**目标**：用私钥 $d$ 对消息 $z$ 进行"盖章"，生成一对整数 $(r, s)$ 。

1. **计算随机点 $R$**：
   利用随机数 $k$ 计算曲线上的点： $R = k \times G$ 。
2. **获取 $r$**：
   取点 $R$ 的 x 坐标： $r = x_R \bmod n$
3. **计算 $s$** (核心公式)：
   结合私钥、消息和随机数：
   
   $$s = k^{-1} (z + r \cdot d) \bmod n$$
   
   *(注意： $k^{-1}$ 是模逆元，不是小数除法)*

**产出**：签名结果 $(r, s)$ 。

#### 2. 标准验签：验证 $(r, s)$
**场景**：验证者已知发件人的公钥 $Q$ 。
**目标**：确认签名是用对应 $Q$ 的私钥 $d$ 签的。

1. **计算逆元 $w$**：
   解开 $s$ 的倒数： $w = s^{-1} \bmod n$
2. **计算中间分量 $u_1, u_2$**：
   
   $$u_1 = z \cdot w \bmod n$$
   $$u_2 = r \cdot w \bmod n$$
   
3. **重构点 $P$**：
   
   $$P = u_1 \cdot G + u_2 \cdot Q$$
   
4. **最终判定**：
   检查点 $P$ 的 x 坐标是否等于 $r$ 。
   
   $$x_P \stackrel{?}{=} r$$

**数学原理**：
通过代数推导证明了 $P = k \cdot G = R$ ，即验证者还原出了签名者当初生成的随机点。

#### 3. 进阶内容：参数 $v$ 与公钥恢复
**场景**：以太坊/比特币交易（为了省去传输长公钥 $Q$ 的空间）。
**输入**：签名 $(r, s, v)$ + 消息 $z$ 。

- **$v$ 的作用 (RecID)**：
  由于椭圆曲线对称，一个 x 坐标对应两个 y 坐标。 $v$ (如 27/28) 告诉验证者点 $R$ 是"上面那个"还是"下面那个"。
- **恢复流程**：
  1. 利用 $r$ 和 $v$ 完整复原出随机点 $R$ 。
  2. **反向计算公钥 $Q$**：
     
     $$Q = r^{-1} (s \cdot R - z \cdot G)$$
     
  3. **验证身份**：
     计算 $Hash(Q)$ 得到地址，对比该地址是否是交易的发起者。

### 一张表对比两种模式

| 模式 | 标准验签 (Standard) | 公钥恢复 (Recovery) |
| :--- | :--- | :--- |
| **主要用途** | 传统安全通信 | 区块链交易 (BTC/ETH) |
| **输入数据** | $z, (r, s), \mathbf{Q}$ | $z, (r, s, \mathbf{v})$ |
| **核心逻辑** | 用 $Q$ 算出一个点，看是否等于 $R$ | 用 $R$ 算出一个点，看是否等于 $Q$ |
| **优点** | 逻辑直观 | **省空间** (不需要存/传公钥) |

### 记忆口诀
- **签名**是：随机数 $k$ 藏两边，一个变 $r$ (坐标)，一个变 $s$ (公式混淆)。
- **验签**是：算出 $w$ (s的逆)，拼凑 $u_1, u_2$ ，还原点 $R$ 。
- **$v$** 是：指路牌，有了 $r, s, v$ ，不需要公钥也能算出你是谁。
