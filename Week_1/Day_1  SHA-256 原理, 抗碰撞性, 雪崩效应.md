# 密码学基础深入研究：Hash 函数

**关键词：** SHA-256 原理, 抗碰撞性, 雪崩效应

---

## 1. SHA-256

SHA-256 是比特币挖矿的核心算法。

简单来说，它既是一个**碎纸机**也是一个**指纹提取器**。无论你的输入是什么——是 10000T 的数据还仅仅是 1 bit，它都会输出一个固定长度的值，并且这个过程是不可逆的。

例如，不管是输入一个字母 `s` 还是电影《盗梦空间》的全片，输出的一定是一个 256 位的 Hash 值。
平时我们看到的通常是十六进制的 Hash 值。因为 1 个十六进制字符需要 4 个 bits 来表示，所以 256 位二进制转化为十六进制就是 64 位。这与我们平时看到的长度是一致的。

### 核心机制：它是如何做到的？

如何让任意数据都变成固定长度？
首先，输入的数据并不是一口气处理完的（“不能一口气吃成胖子”）。数据会被切分成 **512 位（bits）** 的小块，然后逐块读取，最终计算出我们需要的结果。

#### 为什么结果是 256 位，但块大小是 512 位？

这里有两个主要原因：

1.  **历史与架构原因：**
    当 2001 年 SHA-256 被设计出来时，主流计算机还是 32 位的。512 位正好可以被 32 整除：
    $$512 / 32 = 16$$
    这意味着一个块正好可以切分为 16 个字（Word），机器处理起来非常“舒适”，不需要复杂的切分或拼凑。

2.  **效率与安全的平衡（搅拌机理论）：**
    我们可以把处理过程比喻为**搅拌机搅拌**。
    * **内部状态（容器）：** 256 位。
    * **输入数据（材料）：** 512 位。
    
    这是一个动态加工过程。如果输入数据太小（用勺子添料），运算效率极低；如果输入数据太大（用直径 10M 的水管灌水），则难以彻底“消化”并保留细节（防止碰撞）。
    **512 位是工程师们找到的平衡点**：既能保证速度够快，又能保证现有结构能把数据变得足够随机和安全。

### 数据填充（Padding）

现实中的数据长度是不规则的，比如单词 `web` 只有 3 个字符（24位），如何变成 512 位的块？
直接补 `0` 是不行的。例如 `101` 补全后是 `101000...`，而 `1010` 补全后也是 `101000...`，这会导致不同的输入产生相同的 Hash，这是绝对不允许的。

**解决方案：**
1.  **补位提示：** 先在数据后面补一个 `1`，作为数据的结束标志。
2.  **填充零：** 随后补 `0`，直到满足特定长度。
3.  **记录长度：** 在最后的 **64 位**记录原始数据的长度。

> **为什么用 64 位记录长度？**
> 这是 SHA-256 的一个限制，意味着它不能处理大小超过 $2^{64}$ 的文件。但这对于目前世界上的绝大多数数据来说已经绰绰有余了。

### 压缩函数与初始向量（IV）

我们可以把 SHA-256 的压缩函数想象成一个**面团**。
拿着 256 位的“面团”，加入 512 位的“香料”（数据块），一直揉，揉到最后又变成 256 位了。大小没变，但味道（特征）已经完全变了——大量的特征被压缩进了一个固定的指纹里。

**初始的面团（Initial Vector）从哪里来？**
不能全设为 `0`，否则第一个块的计算结果会非常有规律，容易被破解。
我们需要一个初始向量（IV），它必须满足两个特征：
1.  **非常乱：** 看起来像随机数。
2.  **绝对客观：** 不能是人为设定的特殊值（防止被怀疑留有后门）。

因此，SHA-256 选择了**前 8 个质数的平方根的小数部分前 32 位**。
例如第一个质数是 2：
$$\sqrt{2} = 1.41421356...$$
转化为十六进制即为 `0x6a09e667`。这就是我们在代码中常看到的神秘数字：

```python
H0 = 0x6a09e667
H1 = 0xbb67ae85
...
```


## 2. 抗碰撞性 (Collision Resistance)

所谓的碰撞，就是输入了两个完全不同的东西，但输出结果竟然一样。
数学表达为：

$$Input A \neq Input B$$
$$Hash(A) = Hash(B)$$

这就像人脸识别时，你和我被识别成了同一个人，这是极其危险的！

在密码学中，我们需要诚实地承认：**碰撞是绝对存在的**。
这就是 **鸽巢原理 (Pigeonhole Principle)**：
* **输入：** 无限的（任何数据，x/n/一本书/所有音乐）。
* **输出：** 有限的（最多 $2^{256}$ 种可能性）。
既然要把无限的东西装进有限的格子里，必然会有两个东西挤在同一个格子里。

但我们强调的是**抗**碰撞性（Collision Resistance），而不是**防**碰撞性（Collision Free）。
虽然碰撞在理论上存在，但你**根本无法在现实时间内把它们找出来**。

这是一种“计算上的安全性”。为了让你感受一下这个“找不出来”到底有多夸张，这里有一个经典的对比：

> 即使把地球上所有的沙子都变成超级计算机，并且让它们从宇宙大爆炸的那一刻开始运算到现在，能找到一对碰撞的概率也只有几十亿分之一。

这就是 SHA-256 给我们的安全感：它在数学上不完美，但在物理世界中坚不可摧。


## 3. 雪崩效应 (Avalanche Effect)

既然我们知道了两个文件的 Hash 值几乎不可能一样，那如果只修改文件中的一个位（Bit）呢？
比如说把一个二进制数从 `1` 改为 `0`，结果会是：

1.  几乎一样（只变了一点点，毕竟原文件 99.99% 都没变）？
2.  **面目全非**（完全看不出它们原本是很像的文件）？

答案是 **2. 面目全非**。这就是我们密码学中的**雪崩效应**。

> 一个小雪球从山上滚下来，最终会变成一个足以摧毁汽车的巨型雪球。

我们改变了一个微小的值，经过不断的“揉搓”运算，这个微小的变化会被不断放大。
最终，新旧 Hash 值之间可能有 **50% 的 bit** 发生改变（即 0 变 1 或 1 变 0），导致结果看起来完全不同。

这正是 SHA-256 的安全性保障。如果变化有规律可循，那么攻击者就会轻易做出逆向推导从而拿到自己想要的东西。正是因为有了雪崩效应，攻击者才无从下手。

### 关于扩散 (Diffusion) 效率

再次回到 512 位块的问题，如果我们把块设置位 10000，而内部状态还是设置为 256，那么结果就会大相径庭。

这是密码学中**扩散 (Diffusion)** 效率的问题：
如果把 10000 份香料强行塞入 256 份面团中，那么每一个香料的影响将会大大减少，有的甚至几乎没有影响。这会降低系统的复杂性，从而提高了逆向攻击的成功概率。

# SHA-256 的三层金字塔架构

## 第一层：原子工具 (The Tools)
这是最底层的螺丝钉，所有运算都依赖它们。

- **XOR ($\oplus$)**：密码学的“魔法胶水”。
  - **特性**：1+1=0 (不进位)，可逆。
  - **作用**：用于混合数据，让你能把东西揉进去，也能（在特定条件下）解出来。

- **ROTR (循环右移)**：信息的“传送带”。
  - **特性**：右边掉出去的位会回到左边。
  - **作用**：保证比特位在移动中一个都不会少，只是换了位置（扩散）。

## 第二层：逻辑组件 (The Components)
用上面的工具组装成的三个核心部件。

- **$\Sigma$ (Sigma 函数)**：“搅拌机”。
  - **原理**：通过多次 ROTR 和 XOR，把一个比特的影响力扩散到 3 个不同的位置。
  - <img width="837" height="211" alt="image" src="https://github.com/user-attachments/assets/6f92d4af-0c55-438f-83a2-465df9db1a69" />


- **$Ch$ (选择函数)**：“双向开关”。
  - **原理**：**$x$** 决定选 $y$ 还是 $z$。引入了非线性，让数学分析变得很困难。
    <img width="949" height="350" alt="image" src="https://github.com/user-attachments/assets/cfb37e19-ad8f-49d0-b904-b12c064f8355" />

- **$Maj$ (多数函数)**：“投票机”。
  - **原理**：少数服从多数。保证输出反映了当前状态的“主流”特征。
    <img width="1039" height="429" alt="image" src="https://github.com/user-attachments/assets/ed17bca4-95d4-489e-af11-9f48f3e31d01" />

## 第三层：生产流水线 (The Assembly Line)
这就是那张复杂的 64 轮循环图。
<img width="1024" height="559" alt="image" src="https://github.com/user-attachments/assets/7ccb9e61-0531-4b46-a885-b53f2268f614" />


- **8 个工位 (A-H)**：我们有 8 个变量作为暂存区。
- **流动规则**：
  - 大部分工位 ($B, C, D, F, G, H$) 只是简单地接过上一棒的数据（大挪移）。
  - 唯独 $A$ 和 $E$ 是“注入口”。它们接收了经过 $\Sigma, Ch, Maj$ 疯狂搅拌后的新数据（以及本轮的消息 $W_t$）。
- **64 轮循环**：
  - 必须转够 64 圈，才能保证最开始注入 $A$ 的那一点点变化，有足够的时间流转到 $H$，再被提取出来重新注入回 $A$，从而彻底地“污染”整个哈希状态（实现雪崩效应）。

---

> **一句话总结**
>
> SHA-256 就是通过 **64 轮** 的循环，利用 **XOR** 和 **ROTR** 这种不丢数据的操作，配合 **$Ch$** 和 **$Maj$** 的复杂逻辑，把你的输入数据彻底“揉碎”并均匀地“涂抹”在 256 位的空间里。


---
*资料来源: NIST SHA-256 Standard*

附件：思维导图
<img width="5381" height="6336" alt="NotebookLM Mind Map (1)" src="https://github.com/user-attachments/assets/30e8caf8-293a-4401-bcb4-2de75b826d61" />
