  多签钱包是区块链世界中最重要的基础设施之一，它管理的资金量甚至超过了许多银行

  我们先从现实生活中的逻辑来讲解
  想象有一个巨大的保险箱：
    普通钱包（EOA）：只有一个钥匙孔，谁拿到钥匙谁就能把钱拿走，太不保险了，万一钥匙丢了都没地找去
    多签钱包（Multi-Sig）：这是一个特制的保险箱，有好几个钥匙孔，需要很多人同时协作才能打开
  我们现在雇了三个人（alice，bob，mark），为了既安全又方便，我们得几个人同时打开比较好？
  如果我们选择三个人同时开：
    假如有一个人去度假了，那么保险柜就打不开了
    如果有一个把钥匙丢了，那么保险柜就永远都打不开了
  所以三个人同时打开不合理，最合理的是两个人
  1.防止作恶：如果一个人就能打开保险柜，那么有可能会被某一人把钱都拿走
  2.防止意外：万一有一个人钥匙丢了，那么两个人还能打开保险柜，这就是容错

  我们现在把上述的变量化作solidity代码：
  拿钥匙的人：
  我们需要一个列表，把这些人都记下来，我们使用一个数组来保存：
  // 这是一个名单，记着谁拿着钥匙
  address[] public owners;
  门槛（threshold）：
  我们要规定几个人同意才能打开保险柜：
  //这是一个数字，比如 2
  uint256 public numConfirmationsRequired；
  在代码中我们通常使用 numConfirmationsRequired 表示需要多少个人确认
  OK，那我们目前为止只有两行数据：
  1.owners[alice，bob，mark]
  2.门槛：2

  想象有一天，我们存的钱越来越多，公司人也越来越多了，三个人管理不太行了，我们改为 50个人管理（Owners），还得雇个保安来保护保险柜
  这时候有人过来说：我是管理员之一，我要打开保险柜
  那么address[] public owners只有这个名单，智能合约（保安）只能这么做：
    拿着名单，看第一行是这个人吗，不是的话看第二行是吗，第三行是吗，一直看完或者找到这个人为止
  这中循环在区块链上是非常昂贵的，名单越长Gas 费越高，如果名单太长的话 GAS可能高到让交易失败！
  我们使用学过的 哈希表来解决：
  我们给保安一个电脑，只要他输入名字（地址）就可以立马显示是不是管理员，不需要手动去翻阅名单了
  所以我们还要加一个状态变量：
  // 输入一个地址，告诉你他是不是管理员
  // 比如输入 Alice 的地址 => 返回 true
  mapping(address => bool) public isOwner;
  这个mapping的作用就是快速证明是不是管理员，方便快捷
  
  那好，我们继续进行
  现在管理人员搞定了，我们就要处理业务了
  当Alice想从保险柜里拿点钱，去uniswap买币的时候，他需要发起一个 提案（Proposal/Transaction)
  这张提案必须写在纸上，让大家都看看，纸上需要写清楚信息。
  第一个就是金额，我们肯定要确定转账金额
  第二个就是转账的地址，我们也需要知道往哪转
  第三个呢就是指令，我们需要知道EVM要处理什么指令，也就是这个提案到底要干嘛
  所以，我们有了以下代码：
  struct Transaction{
    address to; //转给谁
    uint256 value;//多少钱
    bytes data;//什么具体操作

    //还有两个辅助信息，方便管理
    bool executed; //这件事情办完了没？防止重复操作
    uint256 numConfiremations; //现在有几个人通过了这个提案？方便计数
  }
  我们需要一个本子，上面记录了提案的顺序
  Transaction[] public transactions;
  transactions[0] 就是第 1 号提案，transactions[1] 就是第 2 号提案……以此类推。

  
  











































  
