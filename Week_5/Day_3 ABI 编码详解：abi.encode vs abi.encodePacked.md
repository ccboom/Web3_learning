# ABI 编码：智能合约的通用语言

GOOD，能坚持到这里，说明你学习的热情还是很高的。

我们今天来学习的是智能合约与其外部世界沟通的通用语言，**ABI 编码**。

我们拆开来慢慢说说这个长什么样子。

---

## 第一部分：两种编码方式的比喻

### 包装工人的比喻

想象我们是一个工厂里的包装工人，把盒子放到纸箱子里就算完成了包装。

但是两种包装有着不一样的区别。

#### abi.encode()：标准纸箱

EVM 有点强迫症，不管你的数据有多大，他喜欢 32 字节的纸箱子，所以放在这么大的纸箱子里面，独占。

比如我们现在有一个 `1`（盒子）。

那我们现在要把这个 `1` 放到纸箱子里面，虽然 1 只占了很小的一部分，那我们这一个纸箱子也不放别的东西了，用塑料泡沫（也就是 0）把它填满，这样就算包装好了。

```
| 0000..........0001 |  (整整 32 字节，前面全是 0)
```

这个特点就是，不管多大的数据，只要有一个就占 32 字节，其他的用 0 补充。

#### abi.encodePacked()：真空压缩袋

这个就略有不同了，使用这个他不管你是多大的，什么东西，直接全部塞到纸箱子里，一个挨着一个。

比如我们现在有一个 `1`（盒子）和 `111111`（盒子）。

那就会直接放进去：

```
| 1111111 |  (整齐排列，挤在一起）
```

像是真空袋子把数据压缩了一样。

---

## 第二部分：哈希碰撞的危险

### 真空袋漏洞

你明白了这个紧紧挨在一起的特性，我们来看看有什么危险的地方。

假设我们在纸上写字：

**A：**
- 第一行：112
- 第二行：233

**B：**
- 第一行：11
- 第二行：2233

如果我们使用 `abi.encodePacked` 把他们拼在一起会发生什么？

两个纸上写的内容都是 `112233`！

那这个时候生成的哈希值也是一模一样的，这不就产生了碰撞吗，两个不同的东西产生了同一个哈希值。

这就是著名的**真空袋漏洞**。

### 生活中的例子

比如我们要去银行取钱：

**A：**
- 用户：`users`
- 备注：`oul`
- EVM 看到的：`usersoul`
- 哈希值：`0xc7b1f.....`

**B：**
- 用户：`user`
- 备注：`soul`
- EVM 看到的：`usersoul`
- 哈希值：`0xc7b1f....`

虽然两个用户不一样，但是他们的哈希值是一样的！

如果设置同一个哈希值只能执行一次，那么 B 的交易就永远无法执行。但如果不这么设置，黑客就可以利用 A 的签名来伪造 B 的交易。

这就是哈希碰撞的本质：**边界丢失**。

---

## 第三部分：安全使用场景分析

既然明白了这个，我们来作为架构师视角想想，为了节省 gas，我们肯定尽量使用 `abi.encodePacked`。

那么以下两个场景，哪个可以安全使用 `abi.encodePacked`？

### 场景 1：白名单校验

**数据结构**：用户地址 `address` + 用户等级 `uint256`

```solidity
bytes32 hash = keccak256(abi.encodePacked(userAddress, userLevel));
```

### 场景 2：仓库编码

**数据结构**：商品类别 `string` + 商品名称 `string`

```solidity
bytes32 hash = keccak256(abi.encodePacked(category, name));
```

### 答案分析

**场景 1 是安全的**，因为 `address` 和 `uint256` 全是固定长度的字节，我们不需要什么分隔符，我们就知道他们两个的长度，EVM 直接知道了：哦前面 20 位是地址，后面的是等级，所以不会搞混。

**场景 2 是不安全的**。因为 `string` 的长度不是固定的，谁也不知道类别和名称会不会拼起来造成两个名字相同，没有长度标记，就像两团面揉到一起，难以分辨。

---

## 第四部分：底层逻辑

我们接下来看看他们的底层逻辑吧，不能不明不白的就用上了。

EVM 在处理数据时，会有两种不同的收纳方式：

### abi.encode()：标准编码，逻辑：可逆的档案柜

这个是为了能还原编码。

因为长度是固定的，所有的都是 32 位，所以任何拿到数据的人都可以逆向获取原本的数据，使用 `abi.decode()`，还原出来的数据绝对正确。

### abi.encodePacked()：紧凑编码，不可逆的压缩机

为了节省 GAS。

它不管什么数据，都是一个跟着一个，丢掉别的长度记录的东西，因为没有长度，所以很难还原原本的数据到底是什么样的。

### 使用场景

#### 当你需要和对方联系的时候（call），使用 encode 编码

当你需要传参数过去对方的合约，那你必须使用 encode 编码。

这样子传过去的参数才知道哪个是哪个，不会乱，当然，获取返回值的时候也是 encode。

#### 当你需要生成数据指纹的时候，通常使用 encodePacked

当你需要配合 `keccak256` 进行 hash 运算的时候，这时候就可以使用 encodePacked。

hash 函数根本不在乎能不能解码，它只关心数据的唯一性。体积最小的时候，消耗的 gas 当然也是最少的。

**但是**，为了防止碰撞，遇到 `string` 或者 `bytes` 这种可变的变量的时候，还是得使用 encode。

---

## 第五部分：abi.encodeWithSignature

OK，下面我们讲讲老朋友，昨天使用过的 `abi.encodeWithSignature`。

### 定义

这个 `abi.encodeWithSignature` 就相当于，把货物装到箱子里，然后贴一个发给谁的标签。

其实也并不复杂，只是把两个东西粘合起来了：

```
abi.encodeWithSignature = 函数选择器（4字节） + abi.encode(参数）
```

前面 4 个字节表示了你要调用哪个函数，后面的参数就是按照标准格式把参数传进去你要调用的函数。

### 使用场景

通常情况下，我们调用合约都很简单，像调用本地函数一样，编译器会帮你搞定：

```solidity
token.transfer(receiver, amount);
```

但是，有些时候你不知道对方合约的具体代码，你手里只有一个合约地址，这时候你就需要盲打了（Low-level-call）。

你需要手动组装发给 EVM 的数据：

```solidity
(bool success, ) = tokenAddress.call(
    abi.encodeWithSignature("transfer(address,uint256)", receiver, amount)
);
```

EVM 收到这个数据之后，看到前 4 个字节就会明白，原来是要找 transfer 这个功能啊，没问题的，然后把后面的数据传给 transfer。

### 数据结构

我们看看这个 `abi.encodeWithSignature` 之后的数据到底长什么样：

| 部分 | 数据 (Hex) | 解释 |
| :--- | :--- | :--- |
| 头部 | `0xa9059cbb` | 这是核心！`keccak256("transfer(address,uint256)")` 的前 4 位。 |
| 参数1 | `000...000123...` | 地址，补满 32 字节 (同 abi.encode) |
| 参数2 | `000...00064` | 金额 100 (16进制是 64)，补满 32 字节 (同 abi.encode) |

### 新手容易犯错的地方

这里有新手容易犯错的地方，必须牢记：

#### 1. 必须按照原本的规范写，哪怕多一个空格都不行

```solidity
// 错误！逗号后面有个空格
abi.encodeWithSignature("transfer(address, uint256)", ...)
```

这样写的话算出来的前 4 个字节完全变化了，交易会直接 revert。

#### 2. 必须使用标准类型名称

```solidity
// 错误！用了 uint 而不是 uint256
abi.encodeWithSignature("transfer(address,uint)", ...)
```

虽然在 solidity 中 `uint = uint256`，但是计算签名的时候，必须写全称，同理，`int` 也要写为 `int256`。

---

## 第六部分：救星 - abi.encodeCall

这玩意这么麻烦，很容易写错，所以 solidity 在 **0.8.11 版本**中引入了一个救星：`abi.encodeCall`。

```solidity
interface IERC20 {
    function transfer(address to, uint256 amount) external;
}

// 新写法：编译器会帮你检查！
abi.encodeCall(IERC20.transfer, (receiver, amount));
```

### 对比

- **Old (encodeWithSignature)**：你传错了参数类型，编译器不报错，运行时才挂掉。
- **New (encodeCall)**：你传错了参数类型，或者手抖把 `transfer` 拼成了 `transfr`，编译器直接报错，不让你通过。

---

## 总结

### 1. 两种核心编码方式的对比

| 特性 | abi.encode() | abi.encodePacked() |
| :--- | :--- | :--- |
| **比喻** | 32字节的纸箱子 (强迫症) | 真空压缩袋 (紧紧挨着) |
| **底层逻辑** | 标准编码：每个数据独占32字节，不足的补0。 | 紧凑编码：直接拼接数据，无填充，不记录长度。 |
| **可逆性** | 可逆：可通过 `abi.decode()` 完美还原。 | 不可逆：因为丢失了长度信息，难以还原。 |
| **主要用途** | 跨合约通讯 (Call)：发送参数和接收返回值时，确保数据结构清晰不乱。 | 数据指纹 (Hash)：配合 `keccak256` 生成哈希，节省 Gas。 |

### 2. 安全隐患：哈希碰撞 (Hash Collision)

- **风险源头**：使用 `abi.encodePacked` 处理多个变长参数（如 `string` 或 `bytes`）时，由于没有分隔符和长度标记，不同输入可能产生相同的拼接结果（即"真空袋漏洞"）。
- **例子**：`("users", "oul")` 和 `("user", "soul")` 都会变成 `"usersoul"`，导致生成的 Hash 值一致。
- **安全场景**：参数中全是固定长度类型（如 `address`, `uint256`），EVM 知道边界，不会混淆。
- **不安全场景**：参数包含多个动态长度类型（如 `string`, `bytes`），必须改用 `abi.encode()` 以防止碰撞。

### 3. 构建函数调用 (Function Selector)

当需要进行低级调用（Low-level-call）且只有合约地址没有源码时使用：

#### A. 老牌选手：abi.encodeWithSignature

- **结构**：函数选择器 (前4字节) + abi.encode(参数)。
- **原理**：手动组装发给 EVM 的数据包。
- **新手深坑 (严格语法)**：
  - **空格敏感**：`"transfer(address, uint256)"` 不能有空格。
  - **全称规范**：必须用标准类型名称，例如必须写 `uint256` 而不能写 `uint`，否则生成的 Hash 指纹完全不同，导致交易失败。

#### B. 救星选手：abi.encodeCall (Solidity 0.8.11+)

- **优势**：编译器级别的安全检查。
- **对比**：
  - `encodeWithSignature`：写错名字或类型，编译通过，运行时崩溃。
  - `encodeCall`：写错名字或类型，编译直接报错，更加安全且防手抖。

### 一句话总结

为了安全和规范通讯，请默认使用 `abi.encode`；为了省 Gas 做哈希且确定类型安全时，才用 `abi.encodePacked`；手动调用合约时，为了防写错，尽量使用 `abi.encodeCall` 替代老旧的 `encodeWithSignature`。
