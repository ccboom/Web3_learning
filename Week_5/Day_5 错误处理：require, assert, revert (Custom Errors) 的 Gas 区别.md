# Solidity 错误处理与 Gas 优化

今天我们来讲错误处理和 gas 优化。

我们必须从底层概念来开始讲，不然很难理解。

---

## 第一部分：require 和 assert 的本质区别

### 夜店比喻

我们举个简单的例子：

假设我们是一个成年人才能进入的夜店（智能合约）。

#### require：门口的保镖

- 客人拿出来身份证，检查之后才能进入
- 如果看到没成年，保镖就会拒绝让他进入，并退还他没有花完的 gas
- 使用这个处理的是用户的错误输入，或者外部调用失败等，一般都是能预料到的情况

#### assert：房屋结构的水泥柱

- assert 属于是夜店的房屋结构，水泥柱
- 如果水泥柱倒塌了，那么整个夜店也不复存在了，说明本身就有非常严重的 BUG
- 一般使用于检查内部的不变量，比如余额不可能小于 0，这是绝对不能发生的事情

### 汽车比喻

都这么说了，那你肯定会想，assert 这玩意有什么用，怎么可能出现这种情况？

话不能这么说，可能理解有点问题。

我换个说法，比如合约是一辆汽车，那么：

- **require** 像是钥匙检查，你没有钥匙的话连车都启动不了
- **assert** 属于是安全气囊，这是发生危险之后的最后一道保障，你可以不用，但是不能没有

如果黑客袭击或者发生了非常严重的 bug 导致合约出现问题，assert 就是最后一道安全保障。

---

## 第二部分：从 EVM 底层分析 Gas 差异

OK 理解了他们的意思，我们来从 EVM 的内存和字节码层面来讲一下。

### 核心原理

要理解 GAS 的区别，必须理解：**Gas 不仅仅是取决于操作了什么，还取决于携带了多少数据**。

### require(condition, "Error string")

当 require 失败的时候，它必须把错误的信息打包返回给用户。

#### 底层分析

1. **MSTORE**：把错误的字符串，比如 "Error string" 逐步复制到内存中，字符越长，消耗的 gas 越高
2. **ABI 编码**：它不仅仅要存字符串，还得存函数头部、偏移量、字符串长度
3. **revert**：把这一大串数内存数据作为参数抛出，返回给用户

#### GAS 分析

- 你必须在合约里面硬编码错误说明，比如你得写 "Error String" 这个字符串。字符串越长，消耗 GAS 也就越多
- 运行的时候，把这些字符串复制到内存中也是需要花钱的

### assert(condition)

在 Solidity 0.8.0 之后，assert 失败时不再烧光所有 gas，而是抛出一个 `Panic(uint256)`。

#### 底层分析

1. **MSTORE**：它只存两样东西：选择器 `0x4e487b71` 和一个错误的代码（比如 `0x01` 代表 AssertError，`0x11` 代表溢出）
2. **revert**：抛出这 36 个字节的数据（4 字节选择器 + 32 位整数）

#### GAS 分析

- 部署成本很低，只需要简短的指令，代码体积比较小
- 运行时不需要搬运字符，内存操作非常少

### revert CustomError()

这是 Solidity 0.8.4 之后才引入的新错误处理。

#### 底层分析

1. **定义一个错误**：`error DefineError()` 只取它 hash 值的前四位
2. **MSTORE**：仅仅把这 4 个字节写入内存
3. **REVERT**：抛出错误

是不是非常简洁明了？

#### GAS 分析

它最省 gas，因为返回值只有 4 字节，数据的传递最少。

### 对比表格

| 特性 | require("Long String...") | assert(condition) | revert CustomError() |
| :--- | :--- | :--- | :--- |
| **携带数据量** | 大 (4字节 + 偏移量 + 长度 + 字符内容) | 中 (4字节 + 32字节代码) | 极小 (仅 4字节选择器) |
| **部署 Gas** | 最高 (要存字符串常量) | 低 | 最低 |
| **运行时失败 Gas** | 最高 (内存读写多) | 低 | 最低 |
| **语义/用途** | 验证输入/业务逻辑 | 检查不可能发生的内部Bug | 替代 require 的高效方案 |

---

## 第三部分：理解偏移量（Offset）

### 什么是偏移量？

偏移量是 ABI 处理**变长数据**的一种机制。

### 栽树比喻

想象在栽小树，每次栽树都会写上谁栽的。

- 如果每个人栽树的数量是固定的，那么我们很快就能分清楚这棵树是属于谁的
- 如果数量是不固定的，那么给查找带来了麻烦

偏移量就是一个路标，它告诉你说：从第八颗到第十棵树全是张三栽种的，那么你就能明白直接去第八颗开始找你要找的张三种的树。

### ABI 编码示例

假设我们有一个错误 `Error(string)`，内容是 "Low"。ABI 编码出来的数据块（每行 32 字节）长这样：

| 位置 | 内容 (Hex) | 解释 |
| :--- | :--- | :--- |
| 0x00 | 08c379a0... | 函数选择器 (Selector) |
| 0x04 | 0000...0020 | 偏移量 (Offset): 意思是"真正的字符串内容，从这行开始往后数 32字节 (0x20) 的地方开始"。 |
| 0x24 | 0000...0003 | 字符串长度: 只有 3 个字符。 |
| 0x44 | 4c6f7700... | 字符串内容: "Low" (UTF-8 编码)，后面补零。 |

如果有两个参数，比如 `Error(string A, string B)`，那么有了偏移量之后才能知道 A 从哪里结束，B 从哪里开始。

---

## 第四部分：隐蔽的陷阱

### 问题的提出

理解了上面这些，你就可能会想：

从 gas 角度来说 assert 和 Custom Error 比 require 更省钱，我们干脆都用 Custom Error 好了，既省钱还不麻烦。

这里有一个非常隐蔽的陷阱，有些中级开发者也可能会忽略。

想想下面的问题：

> 如果你为了极致的省 gas，把所有所有的 require 全部变为了 `revert CustomError()`
> 
> 这确实降低了部署和失败的时候的 gas
> 
> 但是，在成功的条件下，可能 CustomError 比 require 都贵
> 
> 这是为什么？

### 编译器优化的差异

因为在交易成功的情况下，require 拥有**编译器级服务特权**：

- **碰到 require**：这是编译器亲儿子，直接生成最高效的 OPCODE 序列，检查条件 → 如果通过就继续走 → 失败就转到错误区域。它不需要建立复杂的栈结构，甚至不需要进入一个新的代码块（block）
- **碰到 if (!condition) revert CustomError()**：这是一个手写的分支，编译器先要处理逻辑非，然后建立 if 的分支跳转，有时候为了处理 if 内部潜在的作用域，还会生成一些额外的栈操作或者跳转指令。

### 最佳实践

所以，我们在高频、简单的检查的时候，还是会使用 require 作为助手，因为写起来很快，并且成功之后也非常快。

逻辑业务复杂的时候，我们再用 revert CustomError，比较节省 gas，方便调试。

---

## 第五部分：为什么 Custom Error 更省空间？

### 问题的提出

现在还有一个问题：

比如我们的 require 是：

```solidity
require(..., "Balance 10 is less than 50")
```

但是我们的 Custom Error 是：

```solidity
error NotEnough(uint256 balance, uint256 price);
```

那怎么 Error 比 require 还长，前者比后者还便宜，这是为什么呢？

### 存储方式的差异

#### require 的存储

- **源码**：挺长的
- **编译之后**：EVM 必须把这个字符串中的每一个字都变成 16 进制字符，然后存储在链上的空间
- **后果**：字符串有多长，链上就占多少空间，按字数收费，当然贵了

#### Custom Error 的存储

- **源码**：也不短，带了参数的函数
- **编译之后**：只存储 hash 值的前四位，对的，就是这么简单
- **后果**：链上执行的时候，只保留了 hash 值和两个 uint256 数字，极其简单

### 如何识别错误？

那又有新问题了，我们链上只存了 hash 值和俩数字，到时候怎么知道是哪个函数呢？

我们在编译合约的时候会生成 **ABI 文件**，前端可以拿着这个文件对照，查到 `0xfb8f41b2` 就知道是 `NotEnough` 了。

### 对比表格

| 类型 | 链上实际存储的内容（示意） | 占用大小 |
| :--- | :--- | :--- |
| **Require** | 0x08c379a0 (头部) + "Balance 10 is less than 50" (完整的文本数据) | 非常大 (头部字节数 + 文本长度) |
| **Custom Error** | 0xfb8f41b2 (仅是一个4字节的ID) + 10 + 50 | 非常小 (仅 4字节 + 参数) |

---

## 第六部分：require 的头部字节数详解

### 底层结构

你可能不明白 require 的头部字节数是怎么来的，我们来讲一下：

Require 的底层其实是在调用一个特殊的函数 `Error(string)`。

标准的 ABI 结构如下：

1. **函数选择器**：selector → 4 字节
2. **数据位置**：也就是字符串内容的指针，上面讲过的偏移量 → 32 字节
3. **字符串长度**：告诉 EVM 字符串的长度 → 32 字节
4. **字符串内容**：这个是动态的字节

明白了吗，我们还没写字符串内容，68 字节的空间已经没有了！

### 实例分析

比如我们的 require 是：

```solidity
require(condition, "Low")
```

那么：

| 部件 | 原始大小 | 实际占用 (EVM Slot) | 累计大小 |
| :--- | :--- | :--- | :--- |
| 头部 (Selector) | 4 B | 4 B | 4 B |
| 偏移量 (Offset) | 32 B | 32 B | 36 B |
| 长度 (Length) | 32 B | 32 B | 68 B |
| 内容 ("Low") | 3 B | 32 B (被补全了!) | 100 B |

### 为什么 Low 三个字符占用 32B？

因为 EVM 的内存是按照 32 字节也就是 256 位存放的，你如果写个 low，它也会后面补 0 补满 32 字节。

**为了报错一个 Low，你使用 require 需要 100 字节，但是使用 Error Low()，只需要 4 字节，结果天差地别！**

---

## 总结

### 1. 三种错误处理机制的本质

- **require**：门口保镖，处理预期的用户输入错误，失败时退还剩余 gas
- **assert**：安全气囊，检查不可能发生的内部不变量，是最后的安全保障
- **Custom Error**：现代化的高效错误处理，0.8.4+ 引入

### 2. Gas 消耗对比

| 错误类型 | 部署成本 | 失败时成本 | 成功时成本 | 数据大小 |
| :--- | :--- | :--- | :--- | :--- |
| require("...") | 最高 | 最高 | 最低（编译器优化） | 100+ 字节 |
| assert() | 低 | 低 | 中 | 36 字节 |
| Custom Error | 最低 | 最低 | 中（需要分支判断） | 4+ 字节 |

### 3. 核心优化原理

**require 的开销来源**：
- 必须存储完整的错误字符串（按字符收费）
- ABI 编码需要：选择器(4B) + 偏移量(32B) + 长度(32B) + 内容(补齐到32B)
- 即使 "Low" 只有 3 个字符，也要占用 100 字节

**Custom Error 的优势**：
- 链上只存 4 字节的 hash 值
- 参数直接编码，无需偏移量和长度字段
- 通过 ABI 文件在链下解析错误信息

### 4. 最佳实践建议

- **高频简单检查**：使用 `require`（编译器优化好，成功路径最快）
- **复杂业务逻辑**：使用 `Custom Error`（省 gas，易调试）
- **内部不变量检查**：使用 `assert`（安全保障，不应该失败）

### 5. 一句话总结

错误处理的 Gas 优化本质是在**数据传输量**和**编译器优化**之间做权衡：require 在成功时最快但失败时最贵，Custom Error 在失败时最省但需要手动分支，assert 是内部安全的最后防线。
