# EVM 预编译合约详解

今天一起来深入探讨以太坊中的预编译合约（Precompiled Contracts）。这对于理解 EVM 的底层优化机制至关重要。

---

## 第一部分：什么是预编译合约？

### 问题的提出

简单来说，以太坊上大多数合约都是由 Solidity 编译成的字节码，然后在 EVM 中进一步执行。但这有个问题：对于复杂的数学或者加密运算（比如 hash 运算，椭圆曲线加密运算），如果使用 EVM 中普通字节码去跑，不仅速度极慢，而且会消耗非常多的 GAS。

### 解决方案

为了解决这个问题，以太坊节点客户端（比如 Geth）内置了一些特殊的，用底层语言（如 C++、Go 等）写好的函数。

我们可以把他们想象成 EVM 的**硬件加速器**或者**原始插件**。

这些插件被映射到了非常小的，特定的地址上（比如 `0x01`、`0x02`）。当你向这些地址发送调用的时候，EVM 不会去跑字节码，而是直接执行节点底层的原生代码，速度极快且 gas fee 很低。

---

## 第二部分：如何调用预编译合约？

### 地址映射

可以把以太坊合约想象成打电话。

- **普通合约**：当你部署一个合约的时候，以太坊会给他生成一个很长、很复杂的地址（电话号码），比如 `0x0345648...`。EVM 看到这个地址，就会去读取该地址下的字节码并运行。
- **预编译合约**：他们的地址非常特殊，是固定的且非常短。
  - `ecrecover` 的地址就是 `0x01`。
  - `sha256` 的地址就是 `0x02`。
  - `identity` 的地址就是 `0x04`。

当 EVM 发现你试图给 `0x01` 这种特殊地址打电话的时候，它不会去链上找字节码，而是直接拦截这次呼叫，转而运行以太坊节点软件里写好的底层代码。

### 表象 vs 真相

在 solidity 中，为了方便开发者，编译器把这些调用包装成了看似普通的函数，但在底层，其实就是一次指向这些特殊地址的内存操作。

#### A. 表象：Solidity 写法

调用 ecrecover 看起来像是调用一个内置函数，看起来非常简单：

```solidity
// 看起来只是个普通函数调用
address signer = ecrecover(hash, v, r, s);
```

#### B. 真相：底层的 Yul/Assembly 写法

实际上 EVM 在做这个：

```solidity
assembly {
    // 1. 准备输入数据：把 hash, v, r, s 存到内存里 (假设从内存位置 0 开始)
    // ... (这里省略存储数据的代码)
    
    // 2. 发起调用！
    // staticcall 是调用指令
    // gas() 表示把当前剩余的 gas 都传进去
    // 0x01 就是 ecrecover 的特殊地址！ <--- 关键在这里
    // 0, 128 表示输入数据在内存的起始位置(0)和长度(128字节)
    // 0, 32  表示把输出结果写回内存的起始位置(0)和长度(32字节)
    let success := staticcall(gas(), 0x01, 0, 128, 0, 32)
    
    // 3. 检查是否成功
    if iszero(success) {
        revert(0, 0)
    }
}
```

### 调用的 3 个步骤

1. **打包数据**：把你想要计算的数据整齐的放在内存中
2. **拨打电话**：使用 `staticcall` 指令，目标地址填 `0x01`
3. **取回结果**：EVM 会把计算结果直接写回你指定的内存区域

---

## 第三部分：三大经典预编译合约

### 0x01: ecrecover（椭圆曲线签名恢复）

#### 功能定义

你可以把 `ecrecover` 想象成一个以太坊世界里的**笔迹鉴定专家**。

它的核心功能非常单一但及其重要：你给它看一个签名，它告诉你这个名字是谁签的（还原出签名者的钱包地址）。

#### 输入数据

我们在第一周中学过，验签流程的数学推导 (r, s, v)。

现在的函数长这样：

```solidity
ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s)
```

- **hash**：值得是消息 hash 值，它不看原话，只看这段话的指纹
- **r 和 s**：签名的核心数据，他们是椭圆曲线加密生成的 32 位数字
- **v**：通常是 27 或者 28，帮助判断点的位置是在上面还是在下面

#### 内存布局

刚刚说过要打包数据，如果我们要在底层调用 `0x01`，我们需要把 4 个参数整齐的摆在内存里传给他。

我们在 solidity 看到 v 是 `uint8` 只占一个字节，但是传入预编译合约的内存时，EVM 要求每个参数都必须占据 32 字节，那我们一共 4 个参数，就需要 128 字节。

来看看这 128 字节具体的样子：

| 相对位置 | 真实内容 | 解释 |
| :--- | :--- | :--- |
| +00 (0x00-0x1F) | Hash | 消息的哈希值 (32 bytes) |
| +32 (0x20-0x3F) | 000...001b | V (填充到 32 bytes，通常是 27/28) |
| +64 (0x40-0x5F) | R | 签名数据 R (32 bytes) |
| +96 (0x60-0x7F) | S | 签名数据 S (32 bytes) |

#### 输出结果

我们给专家传递了数据，专家鉴定完之后会给我们一张纸条。

ecrecover 的作用是还原出签名者的地址，我们知道以太坊地址通常是 20 字节长，但是为了符合 EVM 的 32 字节对齐规则，返回结果会被填充：

```
[12 字节的 0] + [20 字节的真实地址]
```

写成 16 进制大概就是 `0x000000000000000000000000 71C765...` (你的地址)

#### ☠️ 致命安全坑

这里有一个非常经典的坑，如果你给专家一个伪造的签名或者格式错误的数据，这个专家（ecrecover 预编译合约）不会报错，也不会大喊这个是假的。他会返回一个特殊的地址，**零地址** (`address(0)`) 即：`0x0000000000000000000000000000000000000000`。

为什么说这是一个巨大的隐患？

假如你写了一个"只要 ecrecover 返回出来的地址，等于 owner（管理员）的地址，我就允许转账"的代码。

想象一下：

1. 黑客随便写了一些数据发过来
2. ecrecover 计算失败，返回了 0 地址
3. 在你的合约里，如果 owner 变量刚好没被赋值，或者你的逻辑里允许了零地址操作，那么 `0 = 0` 成立！黑客成功绕过了签名

#### 正确的防御姿势

```solidity
address signer = ecrecover(...);
// 第一步：先看专家有没有"交白卷"（返回 0）
require(signer != address(0), "Invalid signature!"); 
// 第二步：再看是不是本人
require(signer == owner, "Not authorized!");
```

### 0x02: sha256（哈希计算）

#### 功能定义

SHA-256 就是 `0x02`，这个预编译合约的功能非常简单，你给他一个任意长度的数据它返回给你一个 32 字节的 hash 值。

它的调用逻辑比 ecrecover 简单的多，因为它没有那种复杂的参数对齐要求：

- **输入**：可以是任何东西，长度不限
- **输出**：永远固定 32 字节

#### 为什么需要 SHA-256？

我们在 solidity 代码里，一直使用 `keccak256()` 这个函数，为什么还要占用宝贵的地址来支持 sha256 呢？

**答案是：为了跟比特币和其他系统进行对话。**

##### 为什么要兼容 SHA-256？

1. **比特币的语言**：比特币不仅是挖矿用 SHA256，他的地址生成、交易验证全部都是基于 SHA-256 算法的。
2. **跨链桥**：如果以太坊想要验证一笔比特币交易，智能合约就必须能在 EVM 里计算 SHA-256。
3. **极高的成本**：如果不用预编译合约，solidity 写一个 SHA-256 算法，计算一次可能要消耗几百万 GAS。

所以 `0x02` 就算是以太坊的一个内置比特币翻译器，用来高效处理那些非以太坊原生的加密标准。

#### 如何调用？

这个比 ecrecover 简单多了。因为太常用了，solidity 把它包装成了原生函数。

```solidity
// 输入可以是字符串、数字、或者字节
bytes32 result = sha256(abi.encodePacked("Hello World"));
```

底层逻辑和 `0x01` 一模一样：

1. 把数据存入内存
2. `staticcall(gas, 0x02, 输入位置, 输入长度, 输出位置, 32)`
3. 从内存读回 32 字节结果

搞定！

### 0x04: identity（数据原样返回）

#### 功能定义

它的功能是：你给他发送数据，它原封不动的返回给你。

乍一听是不是觉得，这不是没用的东西吗？其实并不是。

#### 实际应用场景

我们来想象这样一个场景：

假设在 EVM 内存里有一大堆数据，你需要把他们从内存 A 复制到内存 B。

在早期 solidity 或者汇编中，你有两个选择：

##### 1. 普通办法

使用 for 循环，这就好比用勺子搬沙子，你需要写一个循环，读取第一个字节，写到新位置，读取 2 个字节写到新位置。

**后果**：每一次读写都要消耗 Gas，如果数据很大，Gas 费会爆炸。

##### 2. 预编译合约法

这就好比租了一辆卡车。

你告诉 Identity 合约把这一堆沙子搬一下，虽然你付了租车费（调用预编译合约的基础 gas），但它是底层原始代码搬运的，速度极快，且不论搬运多少，都会非常便宜。

#### 存在意义

所以 `0x04` identity 其实是 EVM 的高性能复印机。

他存在的意义就俩字：**省钱**。

当要复制非常大的数据块的时候，调用它比你自己在合约写循环便宜的多。

#### 💰 算笔账

- **普通循环**：每复制 32 字节，大概需要消耗几百 Gas（加载、存储、循环跳转等）。
- **Identity**：基础费用仅 15 Gas，每复制 32 字节只加收 3 Gas。

---

## 总结

### 1. 核心定义：EVM 的"硬件加速器"

**什么是预编译合约？**

它们不是由 Solidity 编译成的字节码，而是以太坊节点客户端（如 Geth）内部用底层语言（Go/C++）写好的原生函数。

**为什么存在？**

EVM 的普通字节码在处理复杂数学运算（如椭圆曲线）或加密运算（如 Hash）时，效率极低且 Gas 消耗极高。

**作用**：

提供极高性能计算，同时大幅降低 Gas 费用。它们被映射到固定的低位地址（0x01, 0x02 等）。

### 2. 调用机制：表象 vs 真相

- **表象（Solidity）**：看起来像调用普通函数，如 `ecrecover(...)`。
- **真相（Assembly/Yul）**：是一次内存操作和特定地址跳转。
- **打包（Pack）**：将参数按 32 字节对齐，整齐排列在内存中。
- **拨号（Call）**：使用 `staticcall(gas, 地址, ...)` 指令，目标地址为 0x01, 0x02 等。
- **取回（Retrieve）**：EVM 拦截调用，运行底层代码，将结果直接写入指定的内存区域。

### 3. 三大经典预编译合约详解

#### A. 0x01: ecrecover (椭圆曲线签名恢复)

- **身份**：笔迹鉴定专家。
- **功能**：输入 (hash, v, r, s)，还原出签名者的地址。
- **内存陷阱**：哪怕 v 是 uint8，在底层传递时也必须填充为 32 字节。
- **☠️ 致命安全坑**：如果签名伪造或格式错误，它不会报错，而是返回零地址 (address(0))。
- **防御代码**：必须先判断 `signer != address(0)`，再判断 `signer == owner`。

#### B. 0x02: sha256 (哈希计算)

- **身份**：比特币翻译器 / 跨链桥梁。
- **功能**：输入任意长度数据，输出固定的 32 字节 Hash 值。
- **存在意义**：虽然以太坊原生使用 Keccak256，但为了兼容比特币（BTC 使用 SHA-256）以及处理跨链验证，必须低成本支持此算法。普通 Solidity 写法跑 SHA-256 会破产，预编译合约则非常便宜。

#### C. 0x04: identity (数据原样返回)

- **身份**：高性能复印机 / 卡车搬运工。
- **功能**：输入什么，返回什么。
- **存在意义**：省钱 (Gas Optimization)。
- **普通做法**：用 Solidity for 循环逐个字节复制内存（像用勺子搬沙子），Gas 极高。
- **0x04 做法**：调用底层 memcpy（像开卡车搬沙子），基础费仅 15 Gas，处理大块内存数据复制时效率极高。

### 4. 一句话总结

预编译合约是以太坊为了突破 EVM 性能瓶颈而开设的"VIP 快速通道"。它们通过固定的特殊地址（0x01-0x09 等），允许开发者以极低的 Gas 成本，直接调用节点底层的高性能原生代码来处理复杂的加密和数据操作。
