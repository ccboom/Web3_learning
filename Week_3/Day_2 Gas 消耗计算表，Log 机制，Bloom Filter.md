# EVM 的 Gas 计费与日志系统

昨天我们学习了 EVM 负责转换状态的机器 $\sigma' = \Upsilon(\sigma, T)$

今天我们给机器加上两个核心限制和功能：

1. **限制**：Gas，你不能让他无限的跑，需要付钱
2. **输出**：Logs 和 Bloom，它跑完之后要告诉外面发生了什么

---

## 第一部分：Gas 消耗计算机制

在黄皮书附录 G 中，Gavin Wood 列出了所有操作码（Opcode）的价格表。

EVM 的计费其实只有两类逻辑：**固定成本（Fixed Cost）** 和 **动态成本（Dynamic Cost）**。

### 1. 固定成本（Fixed Cost）

这些都是一口价，无论你什么时候执行，消耗都一样。

- **极低的消耗**：( $G_{base} = 2$ 或 $G_{verylow} = 3$ )，比如 ADD（加法），POP（出栈）等
- **原因**：这些都是 CPU 也就是你电脑芯片最擅长做的事情，一瞬间就能做完，所以 EVM 收你很便宜的电费。

### 2. 动态成本（Dynamic Cost）

这些操作的费用是不固定的，取决于当时的状态或者你操作的数据量。这里有两个最经典的大坑。

#### A. 内存扩展成本（Memory Expansion Cost）

EVM 的内存是一张白纸，你在上面写字（比如 MSTORE），如果你只用前 1KB，很便宜，如果你突然要在第 100MB 的位置上写一个字，那 GAS 直接爆炸。

**数学原理**：

EVM 的内存消耗公式大致如下：

$$C_{mem}(a) = 3a + \lfloor \frac{a^2}{512} \rfloor$$

- **线性部分**（ $3a$ ）：刚开始用内存很便宜
- **二次方部分**（ $\frac{a^2}{512}$ ）：这才是杀手锏，当你试图把内存扩展到很大时，这一项会呈爆炸式增长，导致 gas 费超过区块上限（Block Gas Limit），交易无法被打包。

这就是为什么写 solidity 的时候尽量复用内存，不要跳着写及其稀疏的数组，否则开荒内存的 gas 能让你破产。

#### B. 存储成本（Storage Cost - SSTORE）

这是 EVM 最贵的操作。SSTORE 把数据写入区块链永久数据库（state Trie）。

**冷与热（Cold VS Warm）**：

EIP-2929 之后，第一次访问一个 slot（Cold）很贵，2100 gas，因为要从磁盘加载到缓存；第二次访问同一个 slot（Warm）就很便宜了，100 Gas 即可。

**脏与净（Dirty vs Clean）**：

- **从 0 改为非 0**：这是在区块链上新建空间，最贵的操作，通常需要 20000 gas + 2100 gas
- **从非 0 改为非 0**：只是修改值，不用新分配空间，没那么贵，通常 2900 gas + 2100 gas
- **从非 0 改为 0**：我们昨天讲过，这是清理垃圾，EVM 甚至会给你 gas 退款（Gas Refund）

### 实例题

你正在写一个智能合约，里面有一个 `uint256 count` 的变量：

- **A**：count 当前是 0，你把它变成 1
- **B**：count 当前是 1，你把他变成 0

虽然在 solidity 代码中，写起来都是 `count++`，但是推测一下，哪个 gas 消耗更多，为什么？

**答案**：

场景 A 消耗的 gas 远比场景 B 多的多。

- **0 → 1（SSTORE_SET）**：这相当于在区块链上开荒，不但要写入新值，还要开辟新的存储槽，所以非常昂贵
- **1 → 0（SSTORE_CLEAR）**：这相当于把原来的数字擦掉，地基已经打好了所以便宜许多，而且还有 gas 退款。

---

## 第二部分：日志（Logs）与布隆过滤器（Bloom Filter）

### 为什么需要日志？

搞定了花钱限制，现在我们看 EVM 的输出系统。

还记得我们刚刚说的吗，在区块链上存数据（SSTORE，把数据写进状态库）是非常贵的。

假设你要做一个微信支付的智能合约：

> A 给 B 转了 10 块

如果不使用日志，那想让用户在手机上看到转账记录，你就得把这行字存到合约的变量中：

```
String record = "A transferred 10 to B";
```

这行字如果存进状态库，估计要花几十块 RMB！每天如果有几万笔交易，光 gas 费都够呛能交得起。

为了解决这个问题，以太坊发明了**日志（Logs）**。

### 日志的比喻

你可以把他当作银行的短信通知：

- **状态（State/Storage）**：就像是银行的金库账本，这里面存的是 A 的余额现在是 1 块，这很重要，必须严谨，放在最安全的地方，当然也最贵。
- **日志（Logs）**：就像银行给你发的短信："您刚才消费了 10 元"
  - 这条短信不会动金库里的钱
  - 这条短信发出去之后，银行就不管了，也不会再去读取
  - 但是，你的手机能收到短信，显示消费成功。

总之，日志就是一种及其便宜的，专门写给链下软件看的历史记录。他比存状态（Storage）大约便宜 10 到 100 倍。

### 日志的结构

在 solidity 代码中，你写 `emit Transfer(from, to, value)` 这就是在打印一张小票。

小票有两半：

#### 第一半：Topics（索引/主题）- 为了方便搜索

这是小票的抬头，好比在整理文件的时候贴的彩色标签。

- **特点**：因为加了标签，所以查起来非常快。
- **限制**：因为要建立索引，所以稍微贵一点点，而且只能贴 4 个标签（其中一个是事件名，剩下三个给你用）
- **例子**：`from`（谁发的）和 `to`（发给谁），这样你就能快速搜索到，哪个是发给我的币。

#### 第二半：Data（数据）- 为了方便读

这是小票的正文，好比文件的详细内容。

- **特点**：非常便宜，想写多少写多少
- **限制**：完全无法搜索，你不能问区块链，把所有转账金额为 100 的交易找出来，因为它被仍在了一堆乱码中，没做索引。
- **例子**：`Value`。通常被扔在 data 中，等会我们在 Bloom 中解释。

### 反直觉的特性

**智能合约自己，是读不到它发出的日志的**。

智能合约可以写：大喊一声 `emit`，发出日志。

智能合约不能读：等合约发完之后，声音就消散在风里了。合约无法在后续代码里去读取之前的日志来做判断。

---

## 第三部分：布隆过滤器（Bloom Filter）

### 问题的提出

我们知道日志是小票，但是区块链上有上亿个区块，每个区块里有几百张小票。当你的钱包想知道有没有人给我转账的时候，它不可能把几亿个区块里的每一张小票都翻一遍，那样早就累死了。

**Bloom Filter** 就是为了解决这个问题的。

### 布隆过滤器的原理

我们来假设一下：

想象一个只存了两本书的小图书馆（一个块）。为了方便大家查找，管理员在门口放了一个黑板（Bloom Filter）上面只有三个格子。

**规则（hash 映射）**：

- 书名字有 A 的，第一格画圈
- 书名字有 B 的，第二格画圈
- 书名字有 C 的，第三格画圈

现在图书馆放入了两本书：

1. Apple - 有 A，第一格画圈
2. Banana - 有 A 也有 B，第一和第二格都画圈

现在的状态：`[ ✅ 第1格 ] [ ✅ 第2格 ] [ ⬜️ 第3格 ]`

### 查询场景

这时候你想找书，你来了：

#### 1. 你想找 CAT 这本书

你看黑板，第三格是空的。可以得出结论，你可以 100% 确定这里面没有 CAT 这本书，直接就可以走（Skip Block）。

这就是 Bloom Filter 最强大的功能：**快速否决**。

#### 2. 你想找的是 ANT

你看黑板，第一格画圈了，里面一定有 ANT 吗？不一定，那个圈也可能是别的画上去的比如 Apple。

这就引出了 Bloom Filter 唯一的副作用：**误报（False Positive）**。

### 权衡分析

那我们想想，如果告诉你可能存在，你下载下来块之后发现并没有你要找的那个交易。

这种白跑一趟的情况，对于你的程序来说最大的损失是什么？

**没有任何损失**，只是浪费了一点计算资源。

这就是 Bloom Filter 的核心权衡，它用偶尔让你白跑一趟，换取了绝大多数时候不用你跑（极高的检索速度和极小的存储空间）。

**特性总结**：

- **没有假阴性（No False Negatives）**：如果 bloom filter 说没有，那就绝对没有
- **只有假阳性（False Positives）**：如果说有，那么只是可能有，你去查了没有也没事。

### 为什么 Value 不做索引？

回到 Value 的问题，为什么 value 通常被扔到 Data 中，而不是 Topics（索引）里面。

真正的原因：**Bloom Filter 是个文科生，它只会对暗号，不会算数学**。

#### 1. Bloom Filter 的死穴：不支持范围搜索

Bloom Filter 的原理是把数据 hash 成一段指纹。

假设我们把金额放进来，哪怕只是一点差距都天差地别：

- 转账 100 元 → 哈希值 `0xabc...`
- 转账 101 元 → 哈希值 `0xff2...`

如果你想做个大额监控，EVM 节点会告诉你真的做不到，因为 Bloom Filter 只能告诉你有没有等于 100 的，不能告诉你大于。如果你要搜大于 100，那么要搜 101、102、103.......直到无穷大的 hash，那根本不可能啊。

#### 2. 为什么地址（address）适合做索引？

address 是离散的，我们通常是精准匹配，比如我想查 `0x12536541....` 这个地址做了什么。Bloom Filter 最擅长做这个事情：对暗号。

所以我们说：**为什么不索引 Value**：不是我们不想搜它，而是通常要按照范围搜索，但底层机制只能做到精准匹配。既然加了也无法实现功能，不如为了省 gas，把他放在便宜的 Data 区域。

---

## 总结

### 一、资源限制：Gas 计费机制 (The Cost)

EVM 不会无限运行，必须付费。计费逻辑分为"固定"与"动态"两类。

#### 1. 固定成本 (Fixed Cost)

- **逻辑**：针对 CPU 运算（如 ADD, POP）。
- **特点**：极度便宜（2-3 Gas），因为这是芯片最擅长的基础运算。

#### 2. 动态成本 (Dynamic Cost)

这是 Gas 消耗的大头，主要包含两类"杀手级"操作：

**A. 内存扩展 (Memory Expansion)**

- **原理**：EVM 内存初始为空。
- **陷阱**：费用包含线性增长（ $3a$ ）和二次方爆炸（ $\lfloor \frac{a^2}{512} \rfloor$ ）。
- **教训**：在 Solidity 中要尽量复用内存，避免跳跃式写入（稀疏数组），否则开荒内存的费用会呈指数级上升。

**B. 存储操作 (SSTORE) - 最昂贵的操作**

- **冷热区分 (EIP-2929)**：第一次读写（Cold）很贵，后续读写（Warm）便宜。
- **脏净区分 (Dirty vs Clean)**：
  - $0 \to$ 非 0 (SET)：最贵（20k+ Gas）。相当于在区块链上"圈地盖房"。
  - 非 0 $\to$ 非 0 (RESET)：较便宜（2.9k+ Gas）。相当于"旧房装修"。
  - 非 0 $\to$ 0 (CLEAR)：最爽。相当于"拆违建"，EVM 会给予 Gas 退款 (Refund)。

**结论**：count 从 0 变 1 的成本远高于从 1 变 2（或 1 变 0）。

### 二、输出系统：日志与检索 (The Output)

由于链上存储（SSTORE）太贵，EVM 设计了日志 (Logs) 作为一种廉价的"旁路"通信机制。

#### 1. 日志 (Logs) - 链下的"银行短信"

- **定位**：比存储便宜 10-100 倍，专门给链下应用（前端、后端）看。
- **特性**：只写不读。智能合约可以发出日志，但自己无法读取历史日志（喊出去的话，自己听不见）。
- **结构**：
  - **Topics (索引/抬头)**：昂贵，限 4 个。用于快速搜索（如：谁转的？from，转给谁？to）。
  - **Data (数据/正文)**：便宜，无限制。用于记录详情（如：转了多少钱 value），但无法被搜索。

#### 2. 布隆过滤器 (Bloom Filter) - 高效检索工具

为了在海量区块中找到即使一张"小票"，EVM 使用了布隆过滤器。

- **核心逻辑**：基于 Hash 映射的位阵列。
- **权衡 (Trade-off)**：
  - **绝无假阴性 (No False Negatives)**：如果过滤器说"这里没有"，那就是真没有（直接跳过区块，省时）。
  - **只有假阳性 (False Positives)**：如果过滤器说"这里有"，那只是可能有（下载下来翻翻看，没有也无所谓，仅浪费一点算力）。

#### 为什么 Value 不做索引？

- **Bloom 的死穴**：Bloom Filter 基于 Hash，Hash 是乱序的。它只能做精准匹配（"等于 100"），无法做范围搜索（"大于 100"）。
- **结论**：因为转账金额通常需要查范围，而 Bloom 做不到，所以为了省钱，通常把 Value 扔进不可搜索但便宜的 Data 区域，而把离散的、通常用于精准匹配的 Address 放入 Topics。
