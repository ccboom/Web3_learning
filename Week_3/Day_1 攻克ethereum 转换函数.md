# 以太坊虚拟机（EVM）详解

今天我们终于正式进入引擎周，开始拆解 Ethereum 虚拟机（EVM）的内部构造。

今天我们的目标非常明确，就是彻底理解这个公式：

$$\boldsymbol{\sigma}' = \Upsilon(\boldsymbol{\sigma}, T)$$

这被称为 **ETH 转换函数（Ethereum State Transition Function）**

---

## 第一部分：世界状态 σ (World State)

### 状态的本质

让我们先看看左边的 $\boldsymbol{\sigma}$ (Sigma)。在黄皮书中，它代表**世界状态**。

以太坊的世界状态其实就是一个巨大的字典（Mapping）：

- **键**：地址（address）
- **值**：账户状态（Account State）

### 账户状态的四个核心字段

每一个账户状态里，严格包含四个核心字段，这也是黄皮书定义的基石：

#### 1. Nonce ( $\sigma[a]_n$ )

- **定义**：这是一个计数器
- **EOA（外部账户）**：代表发出交易的数量
- **合约账户**：代表创建的合约序号
- **作用**：防止重放攻击

#### 2. Balance ( $\sigma[a]_b$ )

- **定义**：表示该地址持有的 Wei 的数量
- **换算**：1 ether = $10^{18}$ Wei
- **注意**：EVM 内部只认 Wei，不认 ether

#### 3. StorageRoot ( $\sigma[a]_s$ )

- **定义**：这是一个 256 位的 hash 值
- **含义**：该账户的私有存储内容构成的 MPT 树的根哈希（root hash）
- **注意**：只有智能合约才有非空的 storage，普通用户的钱包通常这里是空的

#### 4. CodeHash ( $\sigma[a]_c$ )

- **定义**：该账户关联的 EVM 字节码的 hash 值
- **注意**：同上，普通用户为空，合约账户这里是实际代码的 hash 值

### EOA vs 合约账户

思考一下以下的问题，如果我创建了一个普通的 MetaMask 钱包（EOA），和一个部署了的 ERC-20 代币合约，他们有哪些不同？

对于 EOA 来说，就像上面讲解的，StorageRoot 和 CodeHash 是空的值。

但是仅仅是概念上为空，在数据存储的时候可不是：

1. **CodeHash**：它是空字符串的 Keccak-256 的 hash 值
   
   $$\text{Keccak256}("") = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470$$

2. **StorageRoot**：他是空的 MPT 树的根 hash 值
   
   $$0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421$$

记住这俩数字，下次调试客户端数据看到他们就能明白，哦这是一个空账户。

### 合约账户的存储

对于合约账户来说，它的 storageRoot 和 CodeHash 会存什么内容？

- **storageRoot**：指向的就是那颗存储了所有状态变量的 MPT 的根 hash
  - 比如在 ERC-20 合约中，这个树中存储着每一位用户的余额数据（ `mapping(address=> uint256) _balances` ）
  - 如果这棵树的根 hash 变了，那么就意味着有人转账，状态发生了改变

### CodeHash 存储的是什么？

那我们现在想想，存储在 CodeHash 里的，是对 Solidity 源码进行 hash，还是对编译后的 EVM 字节码进行 hash？

让我们从**机器**的角度来看：

- **EVM 不懂 Solidity**：EVM 是一个堆栈机，它根本看不懂 `function`、`if`、`mapping` 这些高级语法，它只能执行像 `PUSH`、`POP` 这样的低级指令（Opcodes）

这下就明白了，存储的是 **EVM 字节码**。

Solidity 源码中有可能包含注释，不同的缩进和变量名，这些都不会实际影响逻辑的运行。如果我们对 Solidity 进行 hash，那这些无关紧要的值就会导致 hash 变化，没有任何正向用处。

所以，CodeHash 其实锚定的是**链上实际执行的机器逻辑**。这也是我们在 Etherscan 上验证合约时，要把源码重新编译，看生成的字节码是否和链上一致。

---

## 第二部分：交易处理 T 与合约创建

### 交易类型的判定

在黄皮书中，$T$ 定义了一系列字段。但是在执行逻辑上，EVM 需要第一时间判断这笔交易的类型。

那么我们想想，在交易的数据结构中，接收方字段处于什么状态时，EVM 会判定这笔交易是创建合约？

**没错就是：空（Empty/Null）**

在底层编码（RLP 编码）中，如果 `to`（接收方）字段是空字节数组（nil），EVM 就会判定这是一笔**合约创建交易(Contract Creation Transaction）**。

### 初始化代码 vs 运行时字节码

在这种情况下，交易中的 `data` 字段就不会再被视为**调用数据的输入**，而是被视为**初始化代码（Init Code）**。

EVM 会执行这段代码，而执行后返回的返回值，才会成为最终部署在链上的**运行时字节码**。

### 合约地址的生成

既然是创建合约，那创建合约得有个地址，这个地址是随机生成的吗？

其实不是的。如果随机的话，那理论上还是能撞上一个有资金的地址，虽然概率很低。

在以太坊中，使用 CREATE 操作码发送 to 为空的交易时，新合约的地址是**确定性计算（Deterministic）**出来的。意味着只要输入参数确定，任何人在任何时候算出来的地址都是一模一样的。

这两个参数一个是 Nonce，一个是 Sender address。

为什么？如果两个人都是第 0 个 nonce 部署合约，那如果没有 address，是不是生成的新地址是一样的？所以这个公式里必须包含：谁创建的。

这就是以太坊黄皮书中定义的传统合约地址生成方式（对应 CREATE 操作码）：

$$\text{NewAddress} = \text{Keccak256}(\text{RLP}(\text{SenderAddress}, \text{Nonce}))[12:]$$

- **SenderAddress**：保证了人与人之间互不干扰
- **Nonce**：保证了这次和下次的互不干扰
- 去哈希值的后 20 个字节，就得到了最终的合约地址

---

## 第三部分：预扣费机制 (Intrinsic Gas)

### 固有 Gas 的概念

接下来，我们 EVM 引擎正式启动，开始运行 $\Upsilon$ 函数。

但是在执行任何一个 Bytecode 之前，EVM 必须先做一个**预扣费**的动作。这被称为 **Intrinsic Gas（固有 gas）**。哪怕你的交易代码全是空的，也得缴费。

### 最低消费的两部分

最低消费包含两部分：

#### 1. 固定费用

- **金额**：21,000 GAS
- **说明**：只要是交易，就要扣 21,000 GAS
- **例子**：这就是为什么普通转账正好是 21,000

#### 2. 数据费用

- **说明**：如果你的交易里携带了 `data`（比如调用合约，部署合约），这部分数据也要按字节收费
- **非 0 字节**：16 Gas
- **0 字节**：4 Gas

### 为什么非 0 字节更贵？

你现在想想，是非 0 的字节贵还是 0 字节贵，为什么？

**非 0 字节更贵**的最重要原因是**区块链存储和带宽**。在底层的 RLP 编码中，一串 0000000000 及其容易压缩，不占什么空间，而非 0 的数据是很难压缩的，实打实的占用了区块的大小和网络传输带宽。

### 为什么正好是 21,000 gas？

这不是随便决定的，我们推理以下。

比如我做了一个转账操作，以太坊底层网络需要做如下步骤：

1. **ECDSA 签名验证**：EVM 必须运行椭圆曲线算法，通过你的签名 $(r, s, v)$ 恢复出你的地址，这是非常复杂的数学运算。如果太便宜的话，攻击者就可以发送大量无效签名，把节点的 CPU 跑爆炸。
   - 成本：大概 3,000 GAS

2. **访问世界状态**：我们刚刚说了 Nonce 和 Balance。为了扣钱和增加 Nonce，EVM 必须去数据库把你的状态读出来，读取在计算机是很慢的操作，所以 GAS 也不便宜。

3. **更新世界状态**：扣完钱后，得把余额和 Nonce 更新以下，写回数据库，写比读操作更贵。
   - 成本：大概 18,000 gas

加起来正好 **21,000 gas**，这个门槛有效的防止了**垃圾交易（spamming）**堵塞网络。

---

## 第四部分：执行环境与架构设计

### 执行环境的构造

终于！要启动了。

在执行第一行代码之前，EVM 会构造一个**执行环境（Context）**，对于 Solidity 开发者来说，这个环境就是你能访问的所有全局变量。

这里有三个概念：

- `msg.value`
- `tx.origin`
- `msg.sender`

### msg.sender vs tx.origin

那么请问，如果 A 调用了合约 B，然后合约 B 调用了合约 C，此时在 C 的执行环境中，`msg.sender` 和 `tx.origin` 分别是谁？

- **msg.sender**：B
- **tx.origin**：A

这也是为什么 Solidity 开发者在做权限检查的时候，通常建议使用 `msg.sender` 而不是 `tx.origin` 的原因，防止被中间人合约进行钓鱼攻击。

### EVM 的三个临时数据区

我们设置好了 context，现在进入：**执行函数(The Execution Function)**，通常记作 $\Xi$ (Xi)。

这一步就是 EVM 的主循环，它不断读取指令，执行指令，扣除 gas，直到代码结束或者 GAS 耗尽。

EVM 还需要三个临时的数据区来辅助计算，这些区域在交易完成的一瞬间就会被销毁：

#### 1. ROM（Read-Only Memory）

- **作用**：存放当前正在执行的合约字节码
- **特性**：只读，不可修改

#### 2. Memory（易变内存）

- **特性**：线性的字节数组，初始大小为 0，可以无限向后扩展
- **寻址**：按照字节寻址
- **成本**：读写虽然比硬盘快，但是扩展太大的话 Gas 费会成指数级增长

#### 3. Stack（堆栈）

- **特性**：EVM 是一个基于堆栈的虚拟机
- **计算**：所有的计算操作都必须在堆栈顶部进行

### 256 位架构的设计哲学

现在我们要触及 EVM 设计哲学中最独特的一点了。

我们的电脑现在一般都是 64 位的，这意味着它一次处理 64 位数据最快，但 EVM 的 Stack 中，每一个 slot 都是 **256-bit**，为什么？

**正是为了密码学运算的效率**。

在区块链世界中，绝大多数核心数据（Keccak-256 hash，椭圆曲线私钥）都是 256 位的。

如果 EVM 是 64 位，那处理一个 hash 值要分成四段，分四次进出寄存器，还要处理进位问题，非常麻烦。

这是一种**重密码学，轻算数**的设计哲学，虽然它让简单的 1 + 1 变得笨重（因为底层要模拟 256 位加法），但是它让验证签名和 hash 及其高效。

---

## 第五部分：操作码与状态修改

### 操作码（Opcodes）

这里的关键：**操作码（Opcodes）**

现在 EVM 的堆栈准备好了，context 也有了，他开始读取那串字节码（Bytecode）。

它是由一个接一个的 byte（十六进制 00 - FF）组成的二进制流，所以叫字节码。

EVM 每读取一个字节就必须知道他要干什么：

- 读到 `0x01` → 执行加法
- 读到 `0xfd` → 交易回滚

这一套数字到动作的映射表，我们叫他**指令集**。

### SSTORE 与 SLOAD

在这个映射表中，唯一能修改我们 StorageRoot 的指令，叫做 **SSTORE（Storage store）**。

它是 EVM 中最昂贵，最重要的操作码之一，他的工作非常简单：从 stack 中拿出一个键值对，然后把数据写入到该账户的 StorageRoot 那颗树里面去。与之对应的读取指令叫 **SLOAD**。

### 原子性（Atomicity）

我们现在有了修改状态的工具（SSTORE），EVM 在执行代码修改状态 $\boldsymbol{\sigma}$。

突然发生了一件事：

代码执行了前 50%，成功用 SSTORE 修改了两个用户的余额，执行到第 51% 的时候，交易突然耗尽了 gas（Out of gas），这种情况下，前一半的做出的修改是会保留在世界状态，还是会全部抹除好像没发生？

**只能是全部抹除**，要么全做，要么全不做，没有做了一半的状态，我们把他叫做**原子性（Atomicity）**。

这里有一个细节，虽然交易回滚了，消耗掉的 gas 是不会给你的。

为什么？因为虽然交易失败了，但是验证者确实为你付出了 CPU 算力来执行那 50% 的代码，所以打包区块的验证者会收走 gas，交易也会上链，不过状态是 Failed。

### Gas 退款（Gas Refund）

既然提到了 gas，EVM 中还有一个有意思的机制：**gas 退款（gas refund）**。

如果你做执行过程中做了一些清理的工作，系统会在交易结束时退还一部分 Gas 给你（最高不超过 GAS 的 20%）。

比如你用 SSTORE 把一个值 100 变成了 0，EVM 就会给你退款。

在底层数据库中把一个值设为 0，等于把这个条目从 MPT 中删除，这意味着所有以太坊节点都能少存一条数据，属于公共利益，减少硬盘占用。

还有一个原因是为了鼓励开发者和用户主动清理不再需要的存储空间，协议会给予 Gas 退款作为奖励。

虽然有退款，但是为了防止恶意利用，退款上限被设定为 20%（伦敦升级之后）。

---

## 第六部分：最终结算 (Final Settlement)

### 代码执行完成后的结算

代码执行完成之后，我们有了新的世界状态 $\boldsymbol{\sigma}'$。

在 $\Upsilon$ 函数输出最终结果之前，必须进行最后的资金结算：

#### 1. 退还剩余的 gas

- **计算**：Gas Limit - Gas Used
- **操作**：退还到你的账户余额

#### 2. 支付矿工/验证者

- **说明**：你消耗的那部分 gas，需要支付给打包的区块验证者

### 为什么支付验证者不消耗 Gas？

支付给验证者的操作不需要消耗 gas，为什么？

#### 原因 1：避免死循环

如果我们这个动作也消耗 gas，那我们会进入死循环：

- 为了支付 gas，就要修改余额
- 修改余额需要消耗 gas
- 消耗 gas 又要付更多的 gas
- 再次修改余额.....

代码都执行完了，用户结算也完成了，这时候再产生新的费用，谁给？

#### 原因 2：系统级特权(System-Level Privilege)

在以太坊协议中，有一类操作是不进过 EVM 指令集，由共识协议直接执行的。

- **交易中**：调用的 ADD、SSTORE 等指令付费，那是因为消耗了公共资源
- **交易后的结算**：EVM 把 gas 算清后，协议层会直接操作底层数据库（World State）把 ETH 加到验证者 Balance 上

这就好像你去超市买东西，收银员收银要你的钱，但是把钱放入到收银机里的动作不用钱。

---

## 总结

### 1. 世界状态 σ (World State)

以太坊的世界状态是一个巨大的映射（Mapping: Address → Account State），每个账户状态包含四个基石字段：

- **Nonce** ( $\sigma[a]_n$ )：计数器。EOA（外部账户）用于记录交易数，合约账户用于记录创建合约的序号。防止重放攻击。
- **Balance** ( $\sigma[a]_b$ )：余额。单位是 Wei（EVM 不认 Ether）。
- **StorageRoot** ( $\sigma[a]_s$ )：存储根。合约私有存储数据的 MPT 树根哈希。EOA 该值为空。
- **CodeHash** ( $\sigma[a]_c$ )：代码哈希。EVM 字节码的 Keccak-256 哈希值（非 Solidity 源码）。EOA 该值为空字符串的哈希。

### 2. 交易处理 T 与合约创建

- **判定标准**：当交易的接收方（to）字段为空 (Empty/Null/nil) 时，EVM 将其识别为合约创建。
- **数据含义**：此时交易的 data 字段被视为初始化代码 (Init Code)，执行后的返回值才是最终上链的运行时字节码。
- **地址生成**：新合约地址是确定性的，计算公式为 $\text{Keccak256}(\text{RLP}(\text{SenderAddress}, \text{Nonce}))[12:]$ 。

### 3. 预扣费机制 (Intrinsic Gas)

在执行任何代码前，必须支付"最低消费"：

- **固定费用**：21,000 Gas。
  - 来源：ECDSA 签名验证（约 3,000 Gas）+ 读写数据库（Balance/Nonce）的 IO 成本（约 18,000 Gas）。
- **数据费用**：
  - 非 0 字节（16 Gas）> 0 字节（4 Gas）。
  - 原因：非 0 数据难以压缩，占用更多链上存储和网络带宽。

### 4. 执行环境与架构设计

- **上下文 (Context)**：
  - `msg.sender`（直接调用者）vs `tx.origin`（原始发起者）。
  - 安全建议：使用 `msg.sender` 以防范中间人钓鱼。
- **数据区域**：
  - ROM：只读，存合约字节码。
  - Memory：易变内存，线性扩展，按字节寻址，成本随大小指数增长。
  - Stack：堆栈，计算核心区域。
- **256 位架构哲学**：
  - EVM 采用了 256-bit Word Size。
  - 原因：为了适配哈希（Keccak-256）和椭圆曲线算法。"重密码学，轻算数" 的设计，牺牲了简单运算的效率，换取了密码学验证的高效。

### 5. 状态修改与原子性

- **核心指令**：SSTORE 是唯一能修改 StorageRoot 的指令（昂贵），对应读取指令为 SLOAD。
- **原子性 (Atomicity)**：交易要么全部成功，要么全部失败。
- **Out of Gas**：若执行中途 Gas 耗尽，所有状态修改（余额、存储）全部回滚，但已消耗的 Gas 不退还（用于支付验证者算力）。
- **Gas 退款**：清理存储（将值设为 0）会获得 Gas 退款（上限 20%），鼓励释放公共资源。

### 6. 最终结算 (Final Settlement)

代码执行完毕后，进入协议层结算：

- **退还用户**：Gas Limit - Gas Used 退回给发送者。
- **支付矿工/验证者**：将消耗的 Gas 支付给验证者。
- **系统级特权 (System-Level Privilege)**：此步骤直接操作底层数据库修改验证者余额，不消耗 Gas，也不通过 EVM 指令。避免了"支付 Gas 需要消耗 Gas"的死循环。
