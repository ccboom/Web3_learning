# 手动解码 Input Data

今天为一周做个总结，学习手动解码 Input Data。

当你学会了手动解码 Input Data，你就拥有了透视眼，能看穿任何一笔交易在干什么。

---

## 第一部分：什么是 Input Data？

### 定义

想象你在给智能合约写一封信，信上写着合约地址，内容就是 Input data（在以太坊中也叫 Calldata，我们前面学过）。

这种信必须严格遵守一种名为 **ABI（Application Binary Interface）** 的格式，否则合约看不懂。

### 结构

Input data 的结构由两部分组成，就像**动词 + 宾语**：

1. **函数选择器（Function Selector）**：前 4 个字节（8 个字符）。它告诉合约：我要调用哪个函数
2. **参数（Parameters）**：后面所有的内容。它告诉合约：函数的参数值是多少，所有参数通常以 32 字节（64 个字符）为一组进行打包

---

## 第二部分：实战解码案例

### 交易示例

请看这个交易：https://etherscan.io/tx/0x940146ef6579652b83cad61e8f53fd42de4f8ec193e2682edeeb53ee6d1174e7

这个交易的 Input Data 是：

```
0xa9059cbb0000000000000000000000002cff890f0378a11913b6129b2e97417a2c30268000000000000000000000000000000000000000000000000000000000000000f4
```

我们来一步一步的拆解。

### 步骤 1：去掉前缀

首先，我们把 `0x` 去掉，因为这个只是代表 16 进制的前缀。

### 步骤 2：识别函数选择器

接下来看前 8 个字符，就是函数选择器。

```
a9059cbb
```

这是前八个字符，那么你肯定会问了，我哪知道这是什么意思，对不对？

现在我们有简单的办法，使用 [4byte.directory](https://www.4byte.directory/) 这个网站，输入进去就可以查出来是什么了。

结果如下：

![4byte.directory 查询结果](https://github.com/user-attachments/assets/d0776f46-33bf-4f3c-bf15-7159ed372c83)

你只需要看最小的 ID 即可，99% 都是这种情况。

那我们看这个，那就是 `transfer(address,uint256)` 函数，说明这个交易是在调用 Transfer 函数。

### 步骤 3：解析参数 1（接收方地址）

既然知道了是在转账，那我们接下来要找出，要转给谁？

在 EVM 中，通常是 32 个字节（64 字符）为一组打包。

截取下一个 64 字符，这串字符藏着接收方钱包的地址：

```
0000000000000000000000002cff890f0378a11913b6129b2e97417a2c302680
```

这就是 EVM 处理地址的方式，虽然钱包地址只有 40 个字符，但 EVM 规定每个参数必须占满 64 字符，所以他会在左边自动补上 24 个 0。

整理好之后，钱包地址就是：

```
0x2cff890f0378a11913b6129b2e97417a2c302680
```

恭喜你成功破解了第一部分参数！

### 步骤 4：解析参数 2（转账金额）

现在我们来找第二部分参数，转账金额。

截取第二部分：

```
00000000000000000000000000000000000000000000000000000000000000f4
```

去掉多余的 0 之后，为字符 `f4`。

这是 16 进制，所以代表的是：

$$15 \times 16 + 4 = 244$$

难道是转了 244 个代币吗？

**不是的**，这里有一个非常重要且容易被忽视的概念：**精度（Decimals）**。

### 步骤 5：处理精度

区块链为了保证计算精确，底层不使用小数点，所以他都会把所有数字放大约 $10^{18}$ 倍（通常是 18 位，也有 6 位的如 USDT）来存储。

如果我们说转一个代币，实际上是转 $1,000,000,000,000,000,000$ 个代币。

但是，我们这次转的是 USDC，实际精度只有 6 位，是为了更接近美元习惯/更像传统金融。

这意味着我们需要把原始数据 244 除以 $10^6$（即 1,000,000）：

$$244 \div 1,000,000 = 0.000244 \text{ USDC}$$

那么转账金额为 **0.000244 USDC**。

到这里 Input data 就全部解析完成了！

---

## 第三部分：自动化工具

### Python 解码脚本

```python
def decode_evm_data(input_data):
    print("-" * 30)
    print("🕵️‍♂️  EVM 数据解码器启动")
    print("-" * 30)

    # 1. 数据清洗：去掉开头的 0x
    clean_data = input_data[2:] if input_data.startswith("0x") else input_data
    
    # 2. 提取函数选择器 (前 8 字符)
    selector = "0x" + clean_data[:8]
    print(f"🔍 函数选择器 (Selector): {selector}")
    print(f"   (提示: 去 4byte.directory 查询这个哈希代表什么函数)")
    
    # 3. 提取参数部分 (剩下的)
    params_content = clean_data[8:]
    
    # 4. 循环切片，每 64 个字符一块
    step = 64
    block_id = 1
    
    # 遍历每一个 64 字符的块
    for i in range(0, len(params_content), step):
        block = params_content[i : i + step]
        
        print(f"\n📦 参数 #{block_id} (原始 Hex):")
        print(f"   {block}")
        
        # --- 视角 A: 假如它是地址 (Address) ---
        # 使用你写的逻辑：取后 40 位
        possible_address = "0x" + block[24:]
        print(f"   👉 [视角 A] 假如是地址: {possible_address}")
        
        # --- 视角 B: 假如它是数字 (Uint256) ---
        try:
            # Python 的 int() 函数，指定基数为 16，可以将 hex 转为 int
            val_int = int(block, 16)
            print(f"   👉 [视角 B] 假如是整数: {val_int}")
            
            # 顺便帮你除以精度看看
            if val_int > 0:
                print(f"      - 若是 USDC (6位): {val_int / 10**6}")
                print(f"      - 若是 ETH  (18位): {val_int / 10**18}")
        except:
            pass
            
        block_id += 1

# --- 测试你的数据 ---
data = "0xa9059cbb0000000000000000000000002cff890f0378a11913b6129b2e97417a2c30268000000000000000000000000000000000000000000000000000000000000000f4"

decode_evm_data(data)
```

---

## 总结

### 1. 核心概念：什么是 Input Data？

- **定义**：Input Data（也称 Calldata）是发送给智能合约的"信件"，告诉合约要做什么。
- **规则**：必须严格遵守 ABI（应用二进制接口）格式。
- **结构**：由"动词"（函数选择器）+"宾语"（参数）组成。

### 2. Input Data 的解剖结构

一段原始数据（如 `0xa9059cbb...`）去除 `0x` 前缀后，可分为两部分：

#### 第一部分：函数选择器 (Function Selector)

- **长度**：前 4 个字节（即 8 个字符）。
- **作用**：告诉合约调用哪个函数（动词）。
- **破解方法**：复制这 8 个字符（例如 `a9059cbb`），去 [4byte.directory](https://www.4byte.directory/) 网站查询。通常 ID 最小的结果即为正确函数（本例中为 ERC-20 的 transfer 方法）。

#### 第二部分：参数 (Parameters)

- **长度**：每 32 个字节（即 64 个字符）为一组进行打包。
- **作用**：告诉合约具体的数值或地址（宾语）。
- **填充规则**：EVM 规定每个参数占满 64 字符，不足的部分会自动补 0（通常在左侧）。

### 3. 实战解码案例：转账交易 (Transfer)

以数据 `0xa9059cbb...f4` 为例，拆解如下：

**识别动作**：

`a9059cbb` → `transfer(address,uint256)`。表示这是一个转账操作。

**解析参数 1（接收方地址）**：

- 截取紧接的 64 个字符。
- 去除左侧填充的 0，提取后 40 个字符。
- 结果：`0x2cff...2680`。

**解析参数 2（转账金额）**：

- 截取再下一个 64 个字符。
- 去除填充的 0，得到 `f4`。
- 16 进制转 10 进制：$15 \times 16 + 4 = 244$。

### 4. 关键陷阱：精度 (Decimals)

- **原理**：区块链底层不存小数，所有数字都是整数。
- **换算**：必须根据代币的精度进行除法运算。
- **ETH/大部分代币**：精度 18 (除以 $10^{18}$)。
- **USDC/USDT**：精度 6 (除以 $10^6$)。
- **本例结果**：因为是 USDC，所以真实金额为 $244 \div 1,000,000 = 0.000244$ USDC。

### 5. 自动化工具

总结中提供了一个 Python 脚本 `decode_evm_data`，它能模拟上述手动过程：

- 自动清洗 `0x` 前缀。
- 分离并提示查询函数选择器。
- 按 64 字符切片遍历参数。
- 同时提供"地址视角"（截取后 40 位）和"数值视角"（转换整数并计算常见精度）的解码结果。

### 一句话总结

学会解码 Input Data，就是学会了将一串看不懂的 16 进制代码，翻译成"谁（From）调用了什么方法（Selector），向谁（Address）发送了多少金额（Value/Decimals）"的通俗语言。
