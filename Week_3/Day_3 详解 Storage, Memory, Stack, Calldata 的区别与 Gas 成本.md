# EVM 存储架构与 Gas 优化

今天我们进入以太坊开发中最**贵**的，也算最硬核的区域之一：EVM 的存储架构。

90% 的 Gas 优化工作，本质上都是在做数据搬运的工作。如果你能把数据放在正确的地方，你的合约就是跑车，放错地方，那就是吞油的拖拉机。

我们一步一步来拆解这个话题。

---

## 第一部分：会计办公室的比喻

想象 EVM 就是一间会计办公室，你是里面的会计，正在处理一笔交易。

办公室有四个东西存放数据：

1. 巨大的保险柜（Storage）
2. 面前桌子上的草稿纸（Memory）
3. 身上的工具袋（Stack）
4. 客户送来的塑封信（Calldata）

### 1. 巨大的保险柜（Storage）

**特点**：

- **永久性**：这都是最重要的文件，放在保险柜，100 年后再来，它依然在那里
- **全球同步性**：一个保险柜不是你一个人在用，是成千上万个节点都在维护同一个保险柜的状态
- **极其昂贵**：因为要占用全球的内存，所以存东西非常贵，取出来也很贵，都要付租金（Gas fee）

**什么时候用**：

- 需要永久记录某些事情的时候
- 比如张三转了 100 个币给李四
- 比如合约的拥有者是谁

**对应的代码**：

直接写在合约最外层的变量，默认就放在保险柜中：

```solidity
contract Wallet {
    // 这个变量放在【保险柜】里
    // 即使交易结束，明天看，balance 依然保存着
    uint256 public balance; 
}
```

### 2. 桌上的草稿纸（Memory）

**特点**：

- **临时性**：这只是一张纸，处理完这笔交易之后，就扔进垃圾桶了。下一笔交易来的时候，又有一张白纸
- **私有且快速**：这是你手边的纸，写个字，擦掉非常快
- **便宜**：相对于保险柜，草稿纸几乎不要钱（但是用多了还是不行）

**什么时候用**：

- 需要中间计算或者临时处理的时候
- 比如要算 (10+20)*2，这时候可以在草稿纸上算出 30 * 2 = 60，只要把 60 存进去保险柜就行了，30 不需要
- 比如处理很长的文字，你把他处理完之后发出去就不管了

**对应的代码**：

如果想用草稿纸，必须显性的写出 `memory` 关键字：

```solidity
function calculate() public {
    // 这个数组放在【草稿纸】上
    // 函数运行完，这个数组就消失了
    uint[] memory tempNumbers = new uint[](5); 
}
```

### 3. 身上的工具袋（Stack）

现在，虽然你有很大的保险柜（Storage），也有宽敞的桌子（Memory），但你真正干活的时候比如做一个 1 + 1，你不能趴在保险柜上算，也不能一直盯着纸看，你需要把数字拿在手上，算完了再放回去。

Stack 就是你的**手**或者说是**工具袋**。

**特点**：

- **空间极小**：这是致命的限制，你的手只有那么大，拿不了太多东西。EVM 中，深度只有 1024 层，最方便拿到的只有顶部 16 个
- **极快/免费**：把东西拿在手里是最快的，几乎不用钱。
- **后进先出（LIFO）**：就像洗盘子，最后洗的在最上面，拿的时候也是第一个拿

**经典报错**：

新手写合约经常遇到：`CompilerError: Stack too deep`

如果在一个函数里定义了太多的局部变量，搞了十几个，就会出现这个问题。原因就是东西太多了手上拿不下，把一部分东西放到桌子上即可。

### 4. 客户送来的塑封信（Calldata）

就像有一个客户从外面递给你一张纸，上面写：我要给张三转 10 块钱。

这张纸就是 calldata。

**特点**：

- **只读**：这是塑封的纸，你只能看，不能改。如果想改，你得抄到另外的纸上去改
- **便宜**：因为你不用抄，直接读取就行了，所以比 memory 更省钱。

**什么时候用**：

- 主要用于函数的输入参数
- 如果参数是一个特别大的数组，而你不用修改它的时候，Calldata 会省很多钱

---

## 第二部分：完整工作流程

1. **接单**：窗口进来一张纸，写着：把我的余额加十元（这是 Calldata）
2. **取档**：你走到保险柜前面，取出来查到现在的余额是 50，你把 50 记到手上（从 Storage 到 Stack）
3. **计算**：你在手上计算 50 + 10（这个过程全部在 Stack 中）
4. **存档**：你走到保险柜，把旧的 50 擦掉，写上 60（从 stack 写入 Storage）

注：如果计算很复杂，中间可能会使用桌子（Memory）来做临时记录，但简单加法就在 Stack 中完成。

### 简单对比表

| 名称 | 比喻 | 关键特性 | 只要记住这一句 |
| :--- | :--- | :--- | :--- |
| **Storage** | 巨大的保险柜 | 永久、死贵 | 存活到下一笔交易的数据 |
| **Memory** | 草稿纸 | 临时、可修改 | 函数里的临时变量 |
| **Stack** | 手/工具带 | 极小、运算用 | 也就是只能拿十几个东西，多了会掉 |
| **Calldata** | 塑封信 | 只读、省钱 | 函数参数尽量用它 |

---

## 第三部分：进阶优化 - 变量打包（Variable Packing）

现在我们基本理解了内容，接下来讲的深入一些。

我们回到保险柜：现在我们要知道一点，保险柜里每一个格子，都是大小固定的 32 字节（256 位）。

### 打包规则

1. **租赁**：你每租赁一个格子（slot），就要付一大笔钱（20000 gas）
2. **合租**：如果你的东西很小（比如 16 字节），而下一个东西也很小，solidity 编译器会尝试把他们塞进同一个格子里，这叫**变量打包（Variable Packing）**

### 为什么这个很重要？

想象一下，每一次写硬盘要收 20000，但是你能把两个变量挤到一个格子里，就能省一半的钱！

### 实例对比

#### A：土豪写法

```solidity
contract BadLayout {
    uint128 a; // 16 字节
    uint256 b; // 32 字节 (太大了，跟 a 挤不下)
    uint128 c; // 16 字节 (只能开个新格子)
}
```

- a 占了格子 0 的一半
- b 来了，他有 32 字节，格子 0 不够了，得开新格子，b 占了格子 1
- c 来了，也没招，只能去开格子 2

**结果**：用了三个格子

#### B：大师写法

```solidity
contract GoodLayout {
    uint128 a; // 16 字节
    uint128 c; // 16 字节 (嘿！刚好能挤进格子 0 剩下的空间)
    uint256 b; // 32 字节 (独占格子 1)
}
```

- a 占了格子 0 前一半
- c 来了，发现还有一半，它正好挤进去
- b 独占一个格子

**结果**：用了两个格子！

仅仅交换了一下顺序，就省下了一次开格子的钱！

### 常用大小参考

- `uint256` = 32 字节（一个格子）
- `uint128` = 16 字节（半个格子）
- `uint64` = 8 字节
- `address` = 20 字节
- `bool` = 1 字节（非常小）

---

## 第四部分：避坑指南 - Storage Pointer

这是很多黑客攻击的源头。看代码：

```solidity
contract Doom {
    address public owner; // 住在格子 0
    
    struct User {
        address addr;
        uint256 amount;
    }

    function test() public {
        // 危险！这里用了 storage 但没告诉它指向哪里
        // 默认它会指向合约的第 0 个格子（也就是 owner）
        User storage u; 
        
        // 这行代码实际上会把 msg.sender 覆盖到 owner 身上！
        // 你不知不觉把合约的主人改成了别人！
        u.addr = msg.sender; 
    }
}
```

**现状**：在 Solidity 0.5.0 以后已经修复了这个问题，要求强制初始化。

---

## 第五部分：Gas 计价器 - 状态变更的经济学

我们前面讲过，今天来回顾一下：

### 情况 1：从"无"到"有" (Zero to Non-zero)

**场景**：保险柜里原来是 0（这块地是荒地），你把它改成了 1（盖了座房子）。

**成本**：最贵。

**价格**：22,100 Gas (20k 存储费 + 2.1k 读写基准费)。

**为什么**：因为你在区块链的世界里"创造"了新的状态，增加了全网节点的负担，所以给的最多。

### 情况 2：从"有"到"改" (Non-zero to Non-zero)

**场景**：保险柜里原来是 1（已经有房子了），你把它改成了 2（重新装修了一下）。

**成本**：便宜。

**价格**：5,000 Gas (2.9k 修改费 + 2.1k 读写基准费)。

**为什么**：因为你没占用新的格子，只是改了里面的字，负担小。

### 情况 3：从"有"到"无" (Non-zero to Zero) —— 回血机制！

**场景**：保险柜里原来是 1（有房子），你把它改回了 0（把房子拆了，还归大自然）。

**成本**：负数（退款）！

**价格**：EVM 会给你 Gas Refund (退税)。

**机制**：交易结束时，如果你清理了状态（把非零变成了零），系统会退给你高达 4,800 Gas 的奖励（最高不超过交易总费用的 1/5）。

**专家用途**：有些黑客或套利机器人会在 Gas 便宜的时候存一堆数据（Gas Token），等 Gas 贵的时候把它们全部删成 0，利用退税来抵消交易费。

---

## 总结

### 一、核心场景比喻：会计办公室

我们将 EVM 视为一间正在处理交易的会计办公室，数据存储的四个位置对应如下：

| 存储位置 | 比喻 | 关键特性 | 最佳用途 |
| :--- | :--- | :--- | :--- |
| **Storage** | 巨大的保险柜 | 永久、极贵、全球同步。读写都需要高昂的 Gas。 | 必须永久保存的状态（如余额、合约 Owner）。 |
| **Memory** | 桌上的草稿纸 | 临时、可改、较便宜。交易结束即销毁。 | 复杂的中间计算、处理字符串或数组。 |
| **Stack** | 手 / 工具袋 | 空间极小、免费/极快。只能拿 16 个，深了拿不到。 | 简单的加减运算、基本逻辑判断。(注：变量太多会报 Stack too deep) |
| **Calldata** | 塑封的信件 | 只读、最便宜。不可修改，直接读取。 | 函数的输入参数（尤其是大的数组参数）。 |

### 二、进阶优化：变量打包 (Variable Packing)

**原理**：Storage 的最小存储单位是 Slot（插槽），每个 Slot 为 32 字节（256 位）。

**规则**：Solidity 编译器会尝试将相邻的小变量塞进同一个 Slot。

**土豪写法（浪费 Gas）**：

```
uint128 a (半个格子)
uint256 b (太大了，开新格子)
uint128 c (半个格子，又开新格子)
```

结果：占用 3 个 Slot。

**大师写法（省 Gas）**：

```
uint128 a (半个格子)
uint128 c (凑过来，刚好填满剩下半个)
uint256 b (独占下一个格子)
```

结果：占用 2 个 Slot。省下 20,000 Gas！

**常用大小参考**：

- `uint256` = 32 字节 (满格)
- `address` = 20 字节
- `uint128` = 16 字节
- `uint64` = 8 字节
- `bool` = 1 字节

### 三、避坑指南：Storage Pointer

**陷阱**：在函数内定义 struct 或 array 的 storage 变量但未初始化。

**后果**：默认指向 Slot 0，修改它会直接覆盖合约最开始的状态变量（如 Owner），曾是著名黑客攻击手段。

**现状**：Solidity 0.5.0+ 强制要求初始化，已修复，但需理解原理。

### 四、Gas 计价器：状态变更的经济学

EVM 鼓励清理垃圾，惩罚占用资源。

- **0 → 非 0 (创建)**：最贵 (22.1k Gas)。相当于在区块链上盖新房。
- **非 0 → 非 0 (修改)**：便宜 (5k Gas)。相当于重新装修。
- **非 0 → 0 (删除)**：负数 (获得退税 Refund)。相当于拆房还地，EVM 会奖励你 Gas（最高抵消 1/5 的交易费）。

### 一句话总结

Gas 优化的本质就是：**尽量少用 Storage，如果有必要用，就尽量把能挤在一起的数据挤在一个 Slot 里，用完不再需要的数据记得清零。**
