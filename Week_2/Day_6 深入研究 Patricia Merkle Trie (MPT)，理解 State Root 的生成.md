# Merkle Patricia Trie (MPT) 详解

今天我们来深入研究一下 MPT。

**目标很明确**：搞清楚全节点的数据库到底长什么样，以及 32 字节的 State Root 是怎么算出来的。

---

## MPT 的三个组成部分

MPT 这个名字其实是三个部分组成：

1. **Trie（Prefix Tree 字典树）**
2. **Patricia（空间压缩算法）**
3. **Merkle（加密哈希验证）**

---

## 第一部分：从 Trie 开始

### 基本概念

假设 ETH 的地址和状态只是简单的 Key-Value 对（Key 是地址，Value 是余额等）。

ETH 地址是 16 进制的字符，比如 `0xab....`

如果我们用标准的 Trie 来存储这些路径：

```
根节点
  ↓
下一层是 a
  ↓
下一层是 b
  ↓
以此类推
```

### Trie 的问题

假设 ETH 地址长度为 40 个字符，在一个新网络里面，就有两个账户：

1. `0xabc0000...000`（中间省略 34 个 0）
2. `0xabc0000...001`（同上）

如果我们用普通的、没有任何优化的 Trie 去存储这两个账户，就会发现中间有大量的节点。

在最原始的 Trie 中，每一个字符都代表树的一层。

这棵树的深度实际上是 **40 层**！

为了存这两个长得很像的地址，我们被迫创造了 **39 个中间节点**。

想象一下每一次查找节点都要读取一次数据库（DB），读取一个账户余额竟然需要 40 次数据库操作，那其中 39 次是毫无意义的路过，这对于追求效率的区块链来说是不可接受的。

### Patricia 压缩的解决方案

我们需要把中间的相同的字符压缩到一层，这样就省略了路径，大大减少了时间。

这个方案正是：**Patricia Trie 的核心思想 - 路径压缩**。

- 如果不压缩，我们是在存**字符**
- 如果压缩了，我们是在存**路径片段**

---

## 第二部分：三种节点结构

为了实现这种格式，ETH 的 MPT 被迫设计了三种完全不同的结构的节点：

### 1. Branch Node（分支节点）

- 一个包含了 16 个插槽（0-f 数组）的数组
- 作用：处理分叉点

### 2. Extension Node（扩展节点）

- 只包含了一个 Key（路径片段）和一个 Value（下一个节点的指针）
- 作用：压缩公共路径

### 3. Leaf Node（叶子节点）

- 包含路径片段和最终数据（比如账户余额）
- 作用：存储最终数据

### 对号入座

让我们用之前的例子来说明：

1. **公共路径（abc00....00）**：这是一条长的，没有任何分叉的单行道。
   - Extension Node 的作用正是压缩这种单行道
   - 它只存两个东西：`[Shared_path, Next_node_hash]`
   - 就像快进一样直接跳过这一段

2. **分叉点（0 或 1）**：到了这里，路分成了两条
   - Branch Node 正好处理这种情况
   - 他有 16 个格子来存放
   - 我们这个例子中只占用了 0 和 1 两个格子，其余的不用管他

3. **终点（数据）**：Leaf Node 节点存放
   - 它存储剩下的路径片段（如果有的话）和真正的数据（value）

### 简化后的路径

根据以上的特点之后，我们现在路径变成了这样：

```
Root → [节点 A] → [节点 B] → [节点 C (两个)]
```

非常简洁是不是，看着很舒服，也很容易理解。

现在已经掌握了 MPT 中 Patricia（压缩）和 Trie（树）的精髓，这正是 ETH 状态树高效的关键：

1. **节点 A - Extension Node**：作为压缩器，它把一长串 `abc000...00` 打包，只占用一步，他的 value 字段指向下一个节点（节点 B）
2. **节点 B - Branch Node**：作为路由器，它在索引 0 和 1 的位置分别指向两个不同的叶子节点

---

## 第三部分：Merkle 的魔力

接下来我们讲一下 MPT 最天才的地方，也是它保证数据不被篡改的原因。

### 哈希指针

在普通的数据库中，节点 A 指向节点 B，通常存节点 B 的地址或者 ID。

但在 MPT 中，**节点 A 存储的是节点 B 的 hash 值**，也就是 Merkle 名字的由来。

### 雪崩效应的链式反应

现在回顾一下在之前学过的 hash 函数特性：

如果我现在修改了其中一个叶子节点里面的余额，从 0 改为了 1 亿，那么：

1. **指向它的节点 B（分支节点）的内容和 hash 值会有哪些变化？**
   - 内容改变之后，hash 值因为雪崩效应也改变了

2. **进而，指向节点 B 的节点 A（扩展节点）会发生什么变化？**
   - 节点 A 改变了存储的节点 B 的 hash 值

3. **最终，这对整棵树的 Root Hash 有什么影响？**
   - Root 也改变了

### Merkle 的魔力

这就是 Merkle Patricia Trie（MPT）中 merkle 的魔力。

哪怕只改动了叶子节点里的一个 bit，他的 hash 值会完全改变，导致父节点的内容变化，父节点的 hash 变化等等，最后 Root Hash 也会变成一个完全不同的 32 位字符串。

### State Root 的意义

现在你明白了为什么 ETH 的每一个区块头里，只存了一个 State Root。

虽然全网有几亿账户，但是只要这 32 位确定了，整个 ETH 在这一刻的**世界状态**就被确认为唯一的了。

---

## 第四部分：Gas 机制的经济学

### 为什么 SSTORE 这么贵？

理解了 MPT，就能瞬间明白 ETH gas 机制的一个痛点。

为什么 solidity 中，写的操作 SSTORE 需要高达 20000 gas，但是读的操作 SLOAD，只需要 100-200 gas？

**答案就在 MPT 树里**：

#### 读（SLOAD）- 便宜

- 只需要向下找到叶子节点，拿到路径数据就行了
- 路径是现成的，不需要修改任何节点

#### 写（SSTORE）- 昂贵

- 一旦你修改了叶子节点的数据，它的 hash 变了
- 父节点 hash 变了
- 爷爷节点 hash 变了
- ...
- root hash 也变了！

这意味着数据库必须写入并更新路径上的**所有节点**，这是一串昂贵的 I/O 操作。

---

## 总结

### 1. MPT 的三大基石

MPT 的全称揭示了它的三个组成部分：

- **Trie（字典树/前缀树）**：基本的树状数据结构，用于存储 Key-Value（地址-状态）。
- **Patricia（空间压缩）**：解决标准 Trie 树深度过大、效率低下的问题。
- **Merkle（哈希验证）**：通过哈希指针保证数据的不可篡改性和一致性。

### 2. 问题与解决方案：从 Trie 到 Patricia

**痛点 (The Problem)**：
- 以太坊地址长达 40 个字符（16 进制）。
- 如果用普通 Trie，查找一个地址需要深入 40 层，意味着 40 次数据库 I/O。
- 对于拥有大量公共前缀的地址（如 `0xabc00...00` 和 `0xabc00...01`），中间会有 39 个无用的节点，极度浪费空间和时间。

**优化 (The Solution)**：路径压缩。
- 将中间没有分叉的"单行道"合并，不再存单个字符，而是存储"路径片段"。
- 结果：树的深度大幅降低，数据库读取次数显著减少。

### 3. 三种节点结构（针对压缩的特定设计）

为了实现压缩，MPT 被迫设计了三种不同的节点：

- **Extension Node（扩展节点/压缩器）**：处理公共路径（单行道）。只存 `[共享路径片段, 下一个节点的Hash]`，起到"快进"作用。
- **Branch Node（分支节点/路由器）**：处理分叉点。拥有 16 个槽位（0-f），指向不同的下游路径。
- **Leaf Node（叶子节点/终点）**：存储剩余路径和最终数据（如余额）。

### 4. Merkle 的魔力：安全性与 State Root

**哈希指针**：节点 A 指向节点 B，存的不是 B 的物理地址，而是 B 的内容哈希值。

**雪崩效应**：
- 修改叶子节点（余额 0 → 1 亿）。
- 导致叶子节点 Hash 变了 → 指向它的父节点内容变了 → 父节点 Hash 变了 → ... → Root Hash 变了。

**唯一性**：区块头里那个 32 字节的 State Root，就是这样算出来的。它像一个数字指纹，锁定了全网某一时刻的唯一状态。

### 5. 经济学影响：为什么 SSTORE 这么贵？

通过 MPT 的结构，完美解释了 Gas 机制：

- **读 (SLOAD) - 便宜**：只需要顺着 Hash 向下找到叶子节点读取数据，路径是现成的。
- **写 (SSTORE) - 昂贵 (2 万 Gas)**：
  - 因为 Merkle 的特性，修改底层数据会导致从叶子到树根的整条路径上的所有节点 Hash 全部发生变化。
  - 这意味着必须重新计算并写入路径上所有节点的数据库记录，这是一系列昂贵的 I/O 和计算操作。
